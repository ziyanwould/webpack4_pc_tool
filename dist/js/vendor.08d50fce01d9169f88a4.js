(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[,,function(module,exports,__webpack_require__){eval("__webpack_require__(3)(__webpack_require__(4))\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = window.Zepto;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9femVwdG9AMS4yLjBAemVwdG8vZGlzdC96ZXB0by5qcz83YzkyIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXGxieFxcXFxEZXNrdG9wXFxcXHdlYnBhY2s0X21wYV9kZW1vXFxcXG5vZGVfbW9kdWxlc1xcXFxfc2NyaXB0LWxvYWRlckAwLjcuMkBzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxsYnhcXFxcRGVza3RvcFxcXFx3ZWJwYWNrNF9tcGFfZGVtb1xcXFxub2RlX21vZHVsZXNcXFxcX3Jhdy1sb2FkZXJAMC41LjFAcmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxsYnhcXFxcRGVza3RvcFxcXFx3ZWJwYWNrNF9tcGFfZGVtb1xcXFxub2RlX21vZHVsZXNcXFxcX3plcHRvQDEuMi4wQHplcHRvXFxcXGRpc3RcXFxcemVwdG8uanNcIikpXG5cbi8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cbm1vZHVsZS5leHBvcnRzID0gd2luZG93LlplcHRvOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fc2NyaXB0LWxvYWRlckAwLjcuMkBzY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcz80MzZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("module.exports = \"/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\\n(function(global, factory) {\\n  if (typeof define === 'function' && define.amd)\\n    define(function() { return factory(global) })\\n  else\\n    factory(global)\\n}(this, function(window) {\\n  var Zepto = (function() {\\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\\n    document = window.document,\\n    elementDisplay = {}, classCache = {},\\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\\n    fragmentRE = /^\\\\s*<(\\\\w+|!)[^>]*>/,\\n    singleTagRE = /^<(\\\\w+)\\\\s*\\\\/?>(?:<\\\\/\\\\1>|)$/,\\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\\\w:]+)[^>]*)\\\\/>/ig,\\n    rootNodeRE = /^(?:body|html)$/i,\\n    capitalRE = /([A-Z])/g,\\n\\n    // special attributes that should be get/set via method calls\\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\\n\\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\\n    table = document.createElement('table'),\\n    tableRow = document.createElement('tr'),\\n    containers = {\\n      'tr': document.createElement('tbody'),\\n      'tbody': table, 'thead': table, 'tfoot': table,\\n      'td': tableRow, 'th': tableRow,\\n      '*': document.createElement('div')\\n    },\\n    readyRE = /complete|loaded|interactive/,\\n    simpleSelectorRE = /^[\\\\w-]*$/,\\n    class2type = {},\\n    toString = class2type.toString,\\n    zepto = {},\\n    camelize, uniq,\\n    tempParent = document.createElement('div'),\\n    propMap = {\\n      'tabindex': 'tabIndex',\\n      'readonly': 'readOnly',\\n      'for': 'htmlFor',\\n      'class': 'className',\\n      'maxlength': 'maxLength',\\n      'cellspacing': 'cellSpacing',\\n      'cellpadding': 'cellPadding',\\n      'rowspan': 'rowSpan',\\n      'colspan': 'colSpan',\\n      'usemap': 'useMap',\\n      'frameborder': 'frameBorder',\\n      'contenteditable': 'contentEditable'\\n    },\\n    isArray = Array.isArray ||\\n      function(object){ return object instanceof Array }\\n\\n  zepto.matches = function(element, selector) {\\n    if (!selector || !element || element.nodeType !== 1) return false\\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\\n                          element.mozMatchesSelector || element.oMatchesSelector ||\\n                          element.matchesSelector\\n    if (matchesSelector) return matchesSelector.call(element, selector)\\n    // fall back to performing a selector:\\n    var match, parent = element.parentNode, temp = !parent\\n    if (temp) (parent = tempParent).appendChild(element)\\n    match = ~zepto.qsa(parent, selector).indexOf(element)\\n    temp && tempParent.removeChild(element)\\n    return match\\n  }\\n\\n  function type(obj) {\\n    return obj == null ? String(obj) :\\n      class2type[toString.call(obj)] || \\\"object\\\"\\n  }\\n\\n  function isFunction(value) { return type(value) == \\\"function\\\" }\\n  function isWindow(obj)     { return obj != null && obj == obj.window }\\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\\n  function isObject(obj)     { return type(obj) == \\\"object\\\" }\\n  function isPlainObject(obj) {\\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\\n  }\\n\\n  function likeArray(obj) {\\n    var length = !!obj && 'length' in obj && obj.length,\\n      type = $.type(obj)\\n\\n    return 'function' != type && !isWindow(obj) && (\\n      'array' == type || length === 0 ||\\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\\n    )\\n  }\\n\\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\\n  function dasherize(str) {\\n    return str.replace(/::/g, '/')\\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\\n           .replace(/([a-z\\\\d])([A-Z])/g, '$1_$2')\\n           .replace(/_/g, '-')\\n           .toLowerCase()\\n  }\\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\\n\\n  function classRE(name) {\\n    return name in classCache ?\\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\\\\\s)' + name + '(\\\\\\\\s|$)'))\\n  }\\n\\n  function maybeAddPx(name, value) {\\n    return (typeof value == \\\"number\\\" && !cssNumber[dasherize(name)]) ? value + \\\"px\\\" : value\\n  }\\n\\n  function defaultDisplay(nodeName) {\\n    var element, display\\n    if (!elementDisplay[nodeName]) {\\n      element = document.createElement(nodeName)\\n      document.body.appendChild(element)\\n      display = getComputedStyle(element, '').getPropertyValue(\\\"display\\\")\\n      element.parentNode.removeChild(element)\\n      display == \\\"none\\\" && (display = \\\"block\\\")\\n      elementDisplay[nodeName] = display\\n    }\\n    return elementDisplay[nodeName]\\n  }\\n\\n  function children(element) {\\n    return 'children' in element ?\\n      slice.call(element.children) :\\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\\n  }\\n\\n  function Z(dom, selector) {\\n    var i, len = dom ? dom.length : 0\\n    for (i = 0; i < len; i++) this[i] = dom[i]\\n    this.length = len\\n    this.selector = selector || ''\\n  }\\n\\n  // `$.zepto.fragment` takes a html string and an optional tag name\\n  // to generate DOM nodes from the given html string.\\n  // The generated DOM nodes are returned as an array.\\n  // This function can be overridden in plugins for example to make\\n  // it compatible with browsers that don't support the DOM fully.\\n  zepto.fragment = function(html, name, properties) {\\n    var dom, nodes, container\\n\\n    // A special case optimization for a single tag\\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\\n\\n    if (!dom) {\\n      if (html.replace) html = html.replace(tagExpanderRE, \\\"<$1></$2>\\\")\\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\\n      if (!(name in containers)) name = '*'\\n\\n      container = containers[name]\\n      container.innerHTML = '' + html\\n      dom = $.each(slice.call(container.childNodes), function(){\\n        container.removeChild(this)\\n      })\\n    }\\n\\n    if (isPlainObject(properties)) {\\n      nodes = $(dom)\\n      $.each(properties, function(key, value) {\\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\\n        else nodes.attr(key, value)\\n      })\\n    }\\n\\n    return dom\\n  }\\n\\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\\n  // to the array. This method can be overridden in plugins.\\n  zepto.Z = function(dom, selector) {\\n    return new Z(dom, selector)\\n  }\\n\\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\\n  // collection. This method can be overridden in plugins.\\n  zepto.isZ = function(object) {\\n    return object instanceof zepto.Z\\n  }\\n\\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\\n  // takes a CSS selector and an optional context (and handles various\\n  // special cases).\\n  // This method can be overridden in plugins.\\n  zepto.init = function(selector, context) {\\n    var dom\\n    // If nothing given, return an empty Zepto collection\\n    if (!selector) return zepto.Z()\\n    // Optimize for string selectors\\n    else if (typeof selector == 'string') {\\n      selector = selector.trim()\\n      // If it's a html fragment, create nodes from it\\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\\n      // is thrown if the fragment doesn't begin with <\\n      if (selector[0] == '<' && fragmentRE.test(selector))\\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // If it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // If a function is given, call it when the DOM is ready\\n    else if (isFunction(selector)) return $(document).ready(selector)\\n    // If a Zepto collection is given, just return it\\n    else if (zepto.isZ(selector)) return selector\\n    else {\\n      // normalize array if an array of nodes is given\\n      if (isArray(selector)) dom = compact(selector)\\n      // Wrap DOM nodes.\\n      else if (isObject(selector))\\n        dom = [selector], selector = null\\n      // If it's a html fragment, create nodes from it\\n      else if (fragmentRE.test(selector))\\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // And last but no least, if it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // create a new Zepto collection from the nodes found\\n    return zepto.Z(dom, selector)\\n  }\\n\\n  // `$` will be the base `Zepto` object. When calling this\\n  // function just call `$.zepto.init, which makes the implementation\\n  // details of selecting nodes and creating Zepto collections\\n  // patchable in plugins.\\n  $ = function(selector, context){\\n    return zepto.init(selector, context)\\n  }\\n\\n  function extend(target, source, deep) {\\n    for (key in source)\\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\\n          target[key] = {}\\n        if (isArray(source[key]) && !isArray(target[key]))\\n          target[key] = []\\n        extend(target[key], source[key], deep)\\n      }\\n      else if (source[key] !== undefined) target[key] = source[key]\\n  }\\n\\n  // Copy all but undefined properties from one or more\\n  // objects to the `target` object.\\n  $.extend = function(target){\\n    var deep, args = slice.call(arguments, 1)\\n    if (typeof target == 'boolean') {\\n      deep = target\\n      target = args.shift()\\n    }\\n    args.forEach(function(arg){ extend(target, arg, deep) })\\n    return target\\n  }\\n\\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\\n  // This method can be overridden in plugins.\\n  zepto.qsa = function(element, selector){\\n    var found,\\n        maybeID = selector[0] == '#',\\n        maybeClass = !maybeID && selector[0] == '.',\\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\\n        isSimple = simpleSelectorRE.test(nameOnly)\\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\\n      slice.call(\\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\\n          element.getElementsByTagName(selector) : // Or a tag\\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\\n      )\\n  }\\n\\n  function filtered(nodes, selector) {\\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\\n  }\\n\\n  $.contains = document.documentElement.contains ?\\n    function(parent, node) {\\n      return parent !== node && parent.contains(node)\\n    } :\\n    function(parent, node) {\\n      while (node && (node = node.parentNode))\\n        if (node === parent) return true\\n      return false\\n    }\\n\\n  function funcArg(context, arg, idx, payload) {\\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\\n  }\\n\\n  function setAttribute(node, name, value) {\\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\\n  }\\n\\n  // access className property while respecting SVGAnimatedString\\n  function className(node, value){\\n    var klass = node.className || '',\\n        svg   = klass && klass.baseVal !== undefined\\n\\n    if (value === undefined) return svg ? klass.baseVal : klass\\n    svg ? (klass.baseVal = value) : (node.className = value)\\n  }\\n\\n  // \\\"true\\\"  => true\\n  // \\\"false\\\" => false\\n  // \\\"null\\\"  => null\\n  // \\\"42\\\"    => 42\\n  // \\\"42.5\\\"  => 42.5\\n  // \\\"08\\\"    => \\\"08\\\"\\n  // JSON    => parse if valid\\n  // String  => self\\n  function deserializeValue(value) {\\n    try {\\n      return value ?\\n        value == \\\"true\\\" ||\\n        ( value == \\\"false\\\" ? false :\\n          value == \\\"null\\\" ? null :\\n          +value + \\\"\\\" == value ? +value :\\n          /^[\\\\[\\\\{]/.test(value) ? $.parseJSON(value) :\\n          value )\\n        : value\\n    } catch(e) {\\n      return value\\n    }\\n  }\\n\\n  $.type = type\\n  $.isFunction = isFunction\\n  $.isWindow = isWindow\\n  $.isArray = isArray\\n  $.isPlainObject = isPlainObject\\n\\n  $.isEmptyObject = function(obj) {\\n    var name\\n    for (name in obj) return false\\n    return true\\n  }\\n\\n  $.isNumeric = function(val) {\\n    var num = Number(val), type = typeof val\\n    return val != null && type != 'boolean' &&\\n      (type != 'string' || val.length) &&\\n      !isNaN(num) && isFinite(num) || false\\n  }\\n\\n  $.inArray = function(elem, array, i){\\n    return emptyArray.indexOf.call(array, elem, i)\\n  }\\n\\n  $.camelCase = camelize\\n  $.trim = function(str) {\\n    return str == null ? \\\"\\\" : String.prototype.trim.call(str)\\n  }\\n\\n  // plugin compatibility\\n  $.uuid = 0\\n  $.support = { }\\n  $.expr = { }\\n  $.noop = function() {}\\n\\n  $.map = function(elements, callback){\\n    var value, values = [], i, key\\n    if (likeArray(elements))\\n      for (i = 0; i < elements.length; i++) {\\n        value = callback(elements[i], i)\\n        if (value != null) values.push(value)\\n      }\\n    else\\n      for (key in elements) {\\n        value = callback(elements[key], key)\\n        if (value != null) values.push(value)\\n      }\\n    return flatten(values)\\n  }\\n\\n  $.each = function(elements, callback){\\n    var i, key\\n    if (likeArray(elements)) {\\n      for (i = 0; i < elements.length; i++)\\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\\n    } else {\\n      for (key in elements)\\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\\n    }\\n\\n    return elements\\n  }\\n\\n  $.grep = function(elements, callback){\\n    return filter.call(elements, callback)\\n  }\\n\\n  if (window.JSON) $.parseJSON = JSON.parse\\n\\n  // Populate the class2type map\\n  $.each(\\\"Boolean Number String Function Array Date RegExp Object Error\\\".split(\\\" \\\"), function(i, name) {\\n    class2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase()\\n  })\\n\\n  // Define methods that will be available on all\\n  // Zepto collections\\n  $.fn = {\\n    constructor: zepto.Z,\\n    length: 0,\\n\\n    // Because a collection acts like an array\\n    // copy over these useful array functions.\\n    forEach: emptyArray.forEach,\\n    reduce: emptyArray.reduce,\\n    push: emptyArray.push,\\n    sort: emptyArray.sort,\\n    splice: emptyArray.splice,\\n    indexOf: emptyArray.indexOf,\\n    concat: function(){\\n      var i, value, args = []\\n      for (i = 0; i < arguments.length; i++) {\\n        value = arguments[i]\\n        args[i] = zepto.isZ(value) ? value.toArray() : value\\n      }\\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\\n    },\\n\\n    // `map` and `slice` in the jQuery API work differently\\n    // from their array counterparts\\n    map: function(fn){\\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\\n    },\\n    slice: function(){\\n      return $(slice.apply(this, arguments))\\n    },\\n\\n    ready: function(callback){\\n      // need to check if document.body exists for IE as that browser reports\\n      // document ready when it hasn't yet created the body element\\n      if (readyRE.test(document.readyState) && document.body) callback($)\\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\\n      return this\\n    },\\n    get: function(idx){\\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\\n    },\\n    toArray: function(){ return this.get() },\\n    size: function(){\\n      return this.length\\n    },\\n    remove: function(){\\n      return this.each(function(){\\n        if (this.parentNode != null)\\n          this.parentNode.removeChild(this)\\n      })\\n    },\\n    each: function(callback){\\n      emptyArray.every.call(this, function(el, idx){\\n        return callback.call(el, idx, el) !== false\\n      })\\n      return this\\n    },\\n    filter: function(selector){\\n      if (isFunction(selector)) return this.not(this.not(selector))\\n      return $(filter.call(this, function(element){\\n        return zepto.matches(element, selector)\\n      }))\\n    },\\n    add: function(selector,context){\\n      return $(uniq(this.concat($(selector,context))))\\n    },\\n    is: function(selector){\\n      return this.length > 0 && zepto.matches(this[0], selector)\\n    },\\n    not: function(selector){\\n      var nodes=[]\\n      if (isFunction(selector) && selector.call !== undefined)\\n        this.each(function(idx){\\n          if (!selector.call(this,idx)) nodes.push(this)\\n        })\\n      else {\\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\\n        this.forEach(function(el){\\n          if (excludes.indexOf(el) < 0) nodes.push(el)\\n        })\\n      }\\n      return $(nodes)\\n    },\\n    has: function(selector){\\n      return this.filter(function(){\\n        return isObject(selector) ?\\n          $.contains(this, selector) :\\n          $(this).find(selector).size()\\n      })\\n    },\\n    eq: function(idx){\\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\\n    },\\n    first: function(){\\n      var el = this[0]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    last: function(){\\n      var el = this[this.length - 1]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    find: function(selector){\\n      var result, $this = this\\n      if (!selector) result = $()\\n      else if (typeof selector == 'object')\\n        result = $(selector).filter(function(){\\n          var node = this\\n          return emptyArray.some.call($this, function(parent){\\n            return $.contains(parent, node)\\n          })\\n        })\\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\\n      return result\\n    },\\n    closest: function(selector, context){\\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\\n      this.each(function(_, node){\\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\\n          node = node !== context && !isDocument(node) && node.parentNode\\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\\n      })\\n      return $(nodes)\\n    },\\n    parents: function(selector){\\n      var ancestors = [], nodes = this\\n      while (nodes.length > 0)\\n        nodes = $.map(nodes, function(node){\\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\\n            ancestors.push(node)\\n            return node\\n          }\\n        })\\n      return filtered(ancestors, selector)\\n    },\\n    parent: function(selector){\\n      return filtered(uniq(this.pluck('parentNode')), selector)\\n    },\\n    children: function(selector){\\n      return filtered(this.map(function(){ return children(this) }), selector)\\n    },\\n    contents: function() {\\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\\n    },\\n    siblings: function(selector){\\n      return filtered(this.map(function(i, el){\\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\\n      }), selector)\\n    },\\n    empty: function(){\\n      return this.each(function(){ this.innerHTML = '' })\\n    },\\n    // `pluck` is borrowed from Prototype.js\\n    pluck: function(property){\\n      return $.map(this, function(el){ return el[property] })\\n    },\\n    show: function(){\\n      return this.each(function(){\\n        this.style.display == \\\"none\\\" && (this.style.display = '')\\n        if (getComputedStyle(this, '').getPropertyValue(\\\"display\\\") == \\\"none\\\")\\n          this.style.display = defaultDisplay(this.nodeName)\\n      })\\n    },\\n    replaceWith: function(newContent){\\n      return this.before(newContent).remove()\\n    },\\n    wrap: function(structure){\\n      var func = isFunction(structure)\\n      if (this[0] && !func)\\n        var dom   = $(structure).get(0),\\n            clone = dom.parentNode || this.length > 1\\n\\n      return this.each(function(index){\\n        $(this).wrapAll(\\n          func ? structure.call(this, index) :\\n            clone ? dom.cloneNode(true) : dom\\n        )\\n      })\\n    },\\n    wrapAll: function(structure){\\n      if (this[0]) {\\n        $(this[0]).before(structure = $(structure))\\n        var children\\n        // drill down to the inmost element\\n        while ((children = structure.children()).length) structure = children.first()\\n        $(structure).append(this)\\n      }\\n      return this\\n    },\\n    wrapInner: function(structure){\\n      var func = isFunction(structure)\\n      return this.each(function(index){\\n        var self = $(this), contents = self.contents(),\\n            dom  = func ? structure.call(this, index) : structure\\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\\n      })\\n    },\\n    unwrap: function(){\\n      this.parent().each(function(){\\n        $(this).replaceWith($(this).children())\\n      })\\n      return this\\n    },\\n    clone: function(){\\n      return this.map(function(){ return this.cloneNode(true) })\\n    },\\n    hide: function(){\\n      return this.css(\\\"display\\\", \\\"none\\\")\\n    },\\n    toggle: function(setting){\\n      return this.each(function(){\\n        var el = $(this)\\n        ;(setting === undefined ? el.css(\\\"display\\\") == \\\"none\\\" : setting) ? el.show() : el.hide()\\n      })\\n    },\\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\\n    html: function(html){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var originHtml = this.innerHTML\\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\\n        }) :\\n        (0 in this ? this[0].innerHTML : null)\\n    },\\n    text: function(text){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var newText = funcArg(this, text, idx, this.textContent)\\n          this.textContent = newText == null ? '' : ''+newText\\n        }) :\\n        (0 in this ? this.pluck('textContent').join(\\\"\\\") : null)\\n    },\\n    attr: function(name, value){\\n      var result\\n      return (typeof name == 'string' && !(1 in arguments)) ?\\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\\n        this.each(function(idx){\\n          if (this.nodeType !== 1) return\\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\\n        })\\n    },\\n    removeAttr: function(name){\\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\\n        setAttribute(this, attribute)\\n      }, this)})\\n    },\\n    prop: function(name, value){\\n      name = propMap[name] || name\\n      return (1 in arguments) ?\\n        this.each(function(idx){\\n          this[name] = funcArg(this, value, idx, this[name])\\n        }) :\\n        (this[0] && this[0][name])\\n    },\\n    removeProp: function(name){\\n      name = propMap[name] || name\\n      return this.each(function(){ delete this[name] })\\n    },\\n    data: function(name, value){\\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\\n\\n      var data = (1 in arguments) ?\\n        this.attr(attrName, value) :\\n        this.attr(attrName)\\n\\n      return data !== null ? deserializeValue(data) : undefined\\n    },\\n    val: function(value){\\n      if (0 in arguments) {\\n        if (value == null) value = \\\"\\\"\\n        return this.each(function(idx){\\n          this.value = funcArg(this, value, idx, this.value)\\n        })\\n      } else {\\n        return this[0] && (this[0].multiple ?\\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\\n           this[0].value)\\n      }\\n    },\\n    offset: function(coordinates){\\n      if (coordinates) return this.each(function(index){\\n        var $this = $(this),\\n            coords = funcArg(this, coordinates, index, $this.offset()),\\n            parentOffset = $this.offsetParent().offset(),\\n            props = {\\n              top:  coords.top  - parentOffset.top,\\n              left: coords.left - parentOffset.left\\n            }\\n\\n        if ($this.css('position') == 'static') props['position'] = 'relative'\\n        $this.css(props)\\n      })\\n      if (!this.length) return null\\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\\n        return {top: 0, left: 0}\\n      var obj = this[0].getBoundingClientRect()\\n      return {\\n        left: obj.left + window.pageXOffset,\\n        top: obj.top + window.pageYOffset,\\n        width: Math.round(obj.width),\\n        height: Math.round(obj.height)\\n      }\\n    },\\n    css: function(property, value){\\n      if (arguments.length < 2) {\\n        var element = this[0]\\n        if (typeof property == 'string') {\\n          if (!element) return\\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\\n        } else if (isArray(property)) {\\n          if (!element) return\\n          var props = {}\\n          var computedStyle = getComputedStyle(element, '')\\n          $.each(property, function(_, prop){\\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\\n          })\\n          return props\\n        }\\n      }\\n\\n      var css = ''\\n      if (type(property) == 'string') {\\n        if (!value && value !== 0)\\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\\n        else\\n          css = dasherize(property) + \\\":\\\" + maybeAddPx(property, value)\\n      } else {\\n        for (key in property)\\n          if (!property[key] && property[key] !== 0)\\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\\n          else\\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\\n      }\\n\\n      return this.each(function(){ this.style.cssText += ';' + css })\\n    },\\n    index: function(element){\\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\\n    },\\n    hasClass: function(name){\\n      if (!name) return false\\n      return emptyArray.some.call(this, function(el){\\n        return this.test(className(el))\\n      }, classRE(name))\\n    },\\n    addClass: function(name){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        classList = []\\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\\n        newName.split(/\\\\s+/g).forEach(function(klass){\\n          if (!$(this).hasClass(klass)) classList.push(klass)\\n        }, this)\\n        classList.length && className(this, cls + (cls ? \\\" \\\" : \\\"\\\") + classList.join(\\\" \\\"))\\n      })\\n    },\\n    removeClass: function(name){\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        if (name === undefined) return className(this, '')\\n        classList = className(this)\\n        funcArg(this, name, idx, classList).split(/\\\\s+/g).forEach(function(klass){\\n          classList = classList.replace(classRE(klass), \\\" \\\")\\n        })\\n        className(this, classList.trim())\\n      })\\n    },\\n    toggleClass: function(name, when){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\\n        names.split(/\\\\s+/g).forEach(function(klass){\\n          (when === undefined ? !$this.hasClass(klass) : when) ?\\n            $this.addClass(klass) : $this.removeClass(klass)\\n        })\\n      })\\n    },\\n    scrollTop: function(value){\\n      if (!this.length) return\\n      var hasScrollTop = 'scrollTop' in this[0]\\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\\n      return this.each(hasScrollTop ?\\n        function(){ this.scrollTop = value } :\\n        function(){ this.scrollTo(this.scrollX, value) })\\n    },\\n    scrollLeft: function(value){\\n      if (!this.length) return\\n      var hasScrollLeft = 'scrollLeft' in this[0]\\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\\n      return this.each(hasScrollLeft ?\\n        function(){ this.scrollLeft = value } :\\n        function(){ this.scrollTo(value, this.scrollY) })\\n    },\\n    position: function() {\\n      if (!this.length) return\\n\\n      var elem = this[0],\\n        // Get *real* offsetParent\\n        offsetParent = this.offsetParent(),\\n        // Get correct offsets\\n        offset       = this.offset(),\\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\\n\\n      // Subtract element margins\\n      // note: when an element has margin: auto the offsetLeft and marginLeft\\n      // are the same in Safari causing offset.left to incorrectly be 0\\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\\n\\n      // Add offsetParent borders\\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\\n\\n      // Subtract the two offsets\\n      return {\\n        top:  offset.top  - parentOffset.top,\\n        left: offset.left - parentOffset.left\\n      }\\n    },\\n    offsetParent: function() {\\n      return this.map(function(){\\n        var parent = this.offsetParent || document.body\\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\\\"position\\\") == \\\"static\\\")\\n          parent = parent.offsetParent\\n        return parent\\n      })\\n    }\\n  }\\n\\n  // for now\\n  $.fn.detach = $.fn.remove\\n\\n  // Generate the `width` and `height` functions\\n  ;['width', 'height'].forEach(function(dimension){\\n    var dimensionProperty =\\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\\n\\n    $.fn[dimension] = function(value){\\n      var offset, el = this[0]\\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\\n        (offset = this.offset()) && offset[dimension]\\n      else return this.each(function(idx){\\n        el = $(this)\\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\\n      })\\n    }\\n  })\\n\\n  function traverseNode(node, fun) {\\n    fun(node)\\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\\n      traverseNode(node.childNodes[i], fun)\\n  }\\n\\n  // Generate the `after`, `prepend`, `before`, `append`,\\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\\n    var inside = operatorIndex % 2 //=> prepend, append\\n\\n    $.fn[operator] = function(){\\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\\n      var argType, nodes = $.map(arguments, function(arg) {\\n            var arr = []\\n            argType = type(arg)\\n            if (argType == \\\"array\\\") {\\n              arg.forEach(function(el) {\\n                if (el.nodeType !== undefined) return arr.push(el)\\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\\n                arr = arr.concat(zepto.fragment(el))\\n              })\\n              return arr\\n            }\\n            return argType == \\\"object\\\" || arg == null ?\\n              arg : zepto.fragment(arg)\\n          }),\\n          parent, copyByClone = this.length > 1\\n      if (nodes.length < 1) return this\\n\\n      return this.each(function(_, target){\\n        parent = inside ? target : target.parentNode\\n\\n        // convert all methods to a \\\"before\\\" operation\\n        target = operatorIndex == 0 ? target.nextSibling :\\n                 operatorIndex == 1 ? target.firstChild :\\n                 operatorIndex == 2 ? target :\\n                 null\\n\\n        var parentInDocument = $.contains(document.documentElement, parent)\\n\\n        nodes.forEach(function(node){\\n          if (copyByClone) node = node.cloneNode(true)\\n          else if (!parent) return $(node).remove()\\n\\n          parent.insertBefore(node, target)\\n          if (parentInDocument) traverseNode(node, function(el){\\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\\n               (!el.type || el.type === 'text/javascript') && !el.src){\\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\\n              target['eval'].call(target, el.innerHTML)\\n            }\\n          })\\n        })\\n      })\\n    }\\n\\n    // after    => insertAfter\\n    // prepend  => prependTo\\n    // before   => insertBefore\\n    // append   => appendTo\\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\\n      $(html)[operator](this)\\n      return this\\n    }\\n  })\\n\\n  zepto.Z.prototype = Z.prototype = $.fn\\n\\n  // Export internal API functions in the `$.zepto` namespace\\n  zepto.uniq = uniq\\n  zepto.deserializeValue = deserializeValue\\n  $.zepto = zepto\\n\\n  return $\\n})()\\n\\nwindow.Zepto = Zepto\\nwindow.$ === undefined && (window.$ = Zepto)\\n\\n;(function($){\\n  var _zid = 1, undefined,\\n      slice = Array.prototype.slice,\\n      isFunction = $.isFunction,\\n      isString = function(obj){ return typeof obj == 'string' },\\n      handlers = {},\\n      specialEvents={},\\n      focusinSupported = 'onfocusin' in window,\\n      focus = { focus: 'focusin', blur: 'focusout' },\\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\\n\\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\\n\\n  function zid(element) {\\n    return element._zid || (element._zid = _zid++)\\n  }\\n  function findHandlers(element, event, fn, selector) {\\n    event = parse(event)\\n    if (event.ns) var matcher = matcherFor(event.ns)\\n    return (handlers[zid(element)] || []).filter(function(handler) {\\n      return handler\\n        && (!event.e  || handler.e == event.e)\\n        && (!event.ns || matcher.test(handler.ns))\\n        && (!fn       || zid(handler.fn) === zid(fn))\\n        && (!selector || handler.sel == selector)\\n    })\\n  }\\n  function parse(event) {\\n    var parts = ('' + event).split('.')\\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\\n  }\\n  function matcherFor(ns) {\\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\\n  }\\n\\n  function eventCapture(handler, captureSetting) {\\n    return handler.del &&\\n      (!focusinSupported && (handler.e in focus)) ||\\n      !!captureSetting\\n  }\\n\\n  function realEvent(type) {\\n    return hover[type] || (focusinSupported && focus[type]) || type\\n  }\\n\\n  function add(element, events, fn, data, selector, delegator, capture){\\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\\n    events.split(/\\\\s/).forEach(function(event){\\n      if (event == 'ready') return $(document).ready(fn)\\n      var handler   = parse(event)\\n      handler.fn    = fn\\n      handler.sel   = selector\\n      // emulate mouseenter, mouseleave\\n      if (handler.e in hover) fn = function(e){\\n        var related = e.relatedTarget\\n        if (!related || (related !== this && !$.contains(this, related)))\\n          return handler.fn.apply(this, arguments)\\n      }\\n      handler.del   = delegator\\n      var callback  = delegator || fn\\n      handler.proxy = function(e){\\n        e = compatible(e)\\n        if (e.isImmediatePropagationStopped()) return\\n        e.data = data\\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\\n        if (result === false) e.preventDefault(), e.stopPropagation()\\n        return result\\n      }\\n      handler.i = set.length\\n      set.push(handler)\\n      if ('addEventListener' in element)\\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n    })\\n  }\\n  function remove(element, events, fn, selector, capture){\\n    var id = zid(element)\\n    ;(events || '').split(/\\\\s/).forEach(function(event){\\n      findHandlers(element, event, fn, selector).forEach(function(handler){\\n        delete handlers[id][handler.i]\\n      if ('removeEventListener' in element)\\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n      })\\n    })\\n  }\\n\\n  $.event = { add: add, remove: remove }\\n\\n  $.proxy = function(fn, context) {\\n    var args = (2 in arguments) && slice.call(arguments, 2)\\n    if (isFunction(fn)) {\\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\\n      proxyFn._zid = zid(fn)\\n      return proxyFn\\n    } else if (isString(context)) {\\n      if (args) {\\n        args.unshift(fn[context], fn)\\n        return $.proxy.apply(null, args)\\n      } else {\\n        return $.proxy(fn[context], fn)\\n      }\\n    } else {\\n      throw new TypeError(\\\"expected function\\\")\\n    }\\n  }\\n\\n  $.fn.bind = function(event, data, callback){\\n    return this.on(event, data, callback)\\n  }\\n  $.fn.unbind = function(event, callback){\\n    return this.off(event, callback)\\n  }\\n  $.fn.one = function(event, selector, data, callback){\\n    return this.on(event, selector, data, callback, 1)\\n  }\\n\\n  var returnTrue = function(){return true},\\n      returnFalse = function(){return false},\\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\\n      eventMethods = {\\n        preventDefault: 'isDefaultPrevented',\\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\\n        stopPropagation: 'isPropagationStopped'\\n      }\\n\\n  function compatible(event, source) {\\n    if (source || !event.isDefaultPrevented) {\\n      source || (source = event)\\n\\n      $.each(eventMethods, function(name, predicate) {\\n        var sourceMethod = source[name]\\n        event[name] = function(){\\n          this[predicate] = returnTrue\\n          return sourceMethod && sourceMethod.apply(source, arguments)\\n        }\\n        event[predicate] = returnFalse\\n      })\\n\\n      event.timeStamp || (event.timeStamp = Date.now())\\n\\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\\n          'returnValue' in source ? source.returnValue === false :\\n          source.getPreventDefault && source.getPreventDefault())\\n        event.isDefaultPrevented = returnTrue\\n    }\\n    return event\\n  }\\n\\n  function createProxy(event) {\\n    var key, proxy = { originalEvent: event }\\n    for (key in event)\\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\\n\\n    return compatible(proxy, event)\\n  }\\n\\n  $.fn.delegate = function(selector, event, callback){\\n    return this.on(event, selector, callback)\\n  }\\n  $.fn.undelegate = function(selector, event, callback){\\n    return this.off(event, selector, callback)\\n  }\\n\\n  $.fn.live = function(event, callback){\\n    $(document.body).delegate(this.selector, event, callback)\\n    return this\\n  }\\n  $.fn.die = function(event, callback){\\n    $(document.body).undelegate(this.selector, event, callback)\\n    return this\\n  }\\n\\n  $.fn.on = function(event, selector, data, callback, one){\\n    var autoRemove, delegator, $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.on(type, selector, data, fn, one)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = data, data = selector, selector = undefined\\n    if (callback === undefined || data === false)\\n      callback = data, data = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(_, element){\\n      if (one) autoRemove = function(e){\\n        remove(element, e.type, callback)\\n        return callback.apply(this, arguments)\\n      }\\n\\n      if (selector) delegator = function(e){\\n        var evt, match = $(e.target).closest(selector, element).get(0)\\n        if (match && match !== element) {\\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\\n        }\\n      }\\n\\n      add(element, event, callback, data, selector, delegator || autoRemove)\\n    })\\n  }\\n  $.fn.off = function(event, selector, callback){\\n    var $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.off(type, selector, fn)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = selector, selector = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(){\\n      remove(this, event, callback, selector)\\n    })\\n  }\\n\\n  $.fn.trigger = function(event, args){\\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\\n    event._args = args\\n    return this.each(function(){\\n      // handle focus(), blur() by calling them directly\\n      if (event.type in focus && typeof this[event.type] == \\\"function\\\") this[event.type]()\\n      // items in the collection might not be DOM elements\\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\\n      else $(this).triggerHandler(event, args)\\n    })\\n  }\\n\\n  // triggers event handlers on current element just as if an event occurred,\\n  // doesn't trigger an actual event, doesn't bubble\\n  $.fn.triggerHandler = function(event, args){\\n    var e, result\\n    this.each(function(i, element){\\n      e = createProxy(isString(event) ? $.Event(event) : event)\\n      e._args = args\\n      e.target = element\\n      $.each(findHandlers(element, event.type || event), function(i, handler){\\n        result = handler.proxy(e)\\n        if (e.isImmediatePropagationStopped()) return false\\n      })\\n    })\\n    return result\\n  }\\n\\n  // shortcut methods for `.bind(event, fn)` for each event type\\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\\n    $.fn[event] = function(callback) {\\n      return (0 in arguments) ?\\n        this.bind(event, callback) :\\n        this.trigger(event)\\n    }\\n  })\\n\\n  $.Event = function(type, props) {\\n    if (!isString(type)) props = type, type = props.type\\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\\n    event.initEvent(type, bubbles, true)\\n    return compatible(event)\\n  }\\n\\n})(Zepto)\\n\\n;(function($){\\n  var jsonpID = +new Date(),\\n      document = window.document,\\n      key,\\n      name,\\n      rscript = /<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,\\n      scriptTypeRE = /^(?:text|application)\\\\/javascript/i,\\n      xmlTypeRE = /^(?:text|application)\\\\/xml/i,\\n      jsonType = 'application/json',\\n      htmlType = 'text/html',\\n      blankRE = /^\\\\s*$/,\\n      originAnchor = document.createElement('a')\\n\\n  originAnchor.href = window.location.href\\n\\n  // trigger a custom event and return false if it was cancelled\\n  function triggerAndReturn(context, eventName, data) {\\n    var event = $.Event(eventName)\\n    $(context).trigger(event, data)\\n    return !event.isDefaultPrevented()\\n  }\\n\\n  // trigger an Ajax \\\"global\\\" event\\n  function triggerGlobal(settings, context, eventName, data) {\\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\\n  }\\n\\n  // Number of active Ajax requests\\n  $.active = 0\\n\\n  function ajaxStart(settings) {\\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\\n  }\\n  function ajaxStop(settings) {\\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\\n  }\\n\\n  // triggers an extra global event \\\"ajaxBeforeSend\\\" that's like \\\"ajaxSend\\\" but cancelable\\n  function ajaxBeforeSend(xhr, settings) {\\n    var context = settings.context\\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\\n      return false\\n\\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\\n  }\\n  function ajaxSuccess(data, xhr, settings, deferred) {\\n    var context = settings.context, status = 'success'\\n    settings.success.call(context, data, status, xhr)\\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\\n    ajaxComplete(status, xhr, settings)\\n  }\\n  // type: \\\"timeout\\\", \\\"error\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxError(error, type, xhr, settings, deferred) {\\n    var context = settings.context\\n    settings.error.call(context, xhr, type, error)\\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\\n    ajaxComplete(type, xhr, settings)\\n  }\\n  // status: \\\"success\\\", \\\"notmodified\\\", \\\"error\\\", \\\"timeout\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxComplete(status, xhr, settings) {\\n    var context = settings.context\\n    settings.complete.call(context, xhr, status)\\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\\n    ajaxStop(settings)\\n  }\\n\\n  function ajaxDataFilter(data, type, settings) {\\n    if (settings.dataFilter == empty) return data\\n    var context = settings.context\\n    return settings.dataFilter.call(context, data, type)\\n  }\\n\\n  // Empty function, used as default callback\\n  function empty() {}\\n\\n  $.ajaxJSONP = function(options, deferred){\\n    if (!('type' in options)) return $.ajax(options)\\n\\n    var _callbackName = options.jsonpCallback,\\n      callbackName = ($.isFunction(_callbackName) ?\\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\\n      script = document.createElement('script'),\\n      originalCallback = window[callbackName],\\n      responseData,\\n      abort = function(errorType) {\\n        $(script).triggerHandler('error', errorType || 'abort')\\n      },\\n      xhr = { abort: abort }, abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    $(script).on('load error', function(e, errorType){\\n      clearTimeout(abortTimeout)\\n      $(script).off().remove()\\n\\n      if (e.type == 'error' || !responseData) {\\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\\n      } else {\\n        ajaxSuccess(responseData[0], xhr, options, deferred)\\n      }\\n\\n      window[callbackName] = originalCallback\\n      if (responseData && $.isFunction(originalCallback))\\n        originalCallback(responseData[0])\\n\\n      originalCallback = responseData = undefined\\n    })\\n\\n    if (ajaxBeforeSend(xhr, options) === false) {\\n      abort('abort')\\n      return xhr\\n    }\\n\\n    window[callbackName] = function(){\\n      responseData = arguments\\n    }\\n\\n    script.src = options.url.replace(/\\\\?(.+)=\\\\?/, '?$1=' + callbackName)\\n    document.head.appendChild(script)\\n\\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\\n      abort('timeout')\\n    }, options.timeout)\\n\\n    return xhr\\n  }\\n\\n  $.ajaxSettings = {\\n    // Default type of request\\n    type: 'GET',\\n    // Callback that is executed before request\\n    beforeSend: empty,\\n    // Callback that is executed if the request succeeds\\n    success: empty,\\n    // Callback that is executed the the server drops error\\n    error: empty,\\n    // Callback that is executed on request complete (both: error and success)\\n    complete: empty,\\n    // The context for the callbacks\\n    context: null,\\n    // Whether to trigger \\\"global\\\" Ajax events\\n    global: true,\\n    // Transport\\n    xhr: function () {\\n      return new window.XMLHttpRequest()\\n    },\\n    // MIME types mapping\\n    // IIS returns Javascript as \\\"application/x-javascript\\\"\\n    accepts: {\\n      script: 'text/javascript, application/javascript, application/x-javascript',\\n      json:   jsonType,\\n      xml:    'application/xml, text/xml',\\n      html:   htmlType,\\n      text:   'text/plain'\\n    },\\n    // Whether the request is to another domain\\n    crossDomain: false,\\n    // Default timeout\\n    timeout: 0,\\n    // Whether data should be serialized to string\\n    processData: true,\\n    // Whether the browser should be allowed to cache GET responses\\n    cache: true,\\n    //Used to handle the raw response data of XMLHttpRequest.\\n    //This is a pre-filtering function to sanitize the response.\\n    //The sanitized response should be returned\\n    dataFilter: empty\\n  }\\n\\n  function mimeToDataType(mime) {\\n    if (mime) mime = mime.split(';', 2)[0]\\n    return mime && ( mime == htmlType ? 'html' :\\n      mime == jsonType ? 'json' :\\n      scriptTypeRE.test(mime) ? 'script' :\\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\\n  }\\n\\n  function appendQuery(url, query) {\\n    if (query == '') return url\\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\\n  }\\n\\n  // serialize payload and append it to the URL for GET requests\\n  function serializeData(options) {\\n    if (options.processData && options.data && $.type(options.data) != \\\"string\\\")\\n      options.data = $.param(options.data, options.traditional)\\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\\n      options.url = appendQuery(options.url, options.data), options.data = undefined\\n  }\\n\\n  $.ajax = function(options){\\n    var settings = $.extend({}, options || {}),\\n        deferred = $.Deferred && $.Deferred(),\\n        urlAnchor, hashIndex\\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\\n\\n    ajaxStart(settings)\\n\\n    if (!settings.crossDomain) {\\n      urlAnchor = document.createElement('a')\\n      urlAnchor.href = settings.url\\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\\n      urlAnchor.href = urlAnchor.href\\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\\n    }\\n\\n    if (!settings.url) settings.url = window.location.toString()\\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\\n    serializeData(settings)\\n\\n    var dataType = settings.dataType, hasPlaceholder = /\\\\?.+=\\\\?/.test(settings.url)\\n    if (hasPlaceholder) dataType = 'jsonp'\\n\\n    if (settings.cache === false || (\\n         (!options || options.cache !== true) &&\\n         ('script' == dataType || 'jsonp' == dataType)\\n        ))\\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\\n\\n    if ('jsonp' == dataType) {\\n      if (!hasPlaceholder)\\n        settings.url = appendQuery(settings.url,\\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\\n      return $.ajaxJSONP(settings, deferred)\\n    }\\n\\n    var mime = settings.accepts[dataType],\\n        headers = { },\\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\\n        protocol = /^([\\\\w-]+:)\\\\/\\\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\\n        xhr = settings.xhr(),\\n        nativeSetHeader = xhr.setRequestHeader,\\n        abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\\n    setHeader('Accept', mime || '*/*')\\n    if (mime = settings.mimeType || mime) {\\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\\n    }\\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\\n\\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\\n    xhr.setRequestHeader = setHeader\\n\\n    xhr.onreadystatechange = function(){\\n      if (xhr.readyState == 4) {\\n        xhr.onreadystatechange = empty\\n        clearTimeout(abortTimeout)\\n        var result, error = false\\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\\n\\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\\n            result = xhr.response\\n          else {\\n            result = xhr.responseText\\n\\n            try {\\n              // http://perfectionkills.com/global-eval-what-are-the-options/\\n              // sanitize response accordingly if data filter callback provided\\n              result = ajaxDataFilter(result, dataType, settings)\\n              if (dataType == 'script')    (1,eval)(result)\\n              else if (dataType == 'xml')  result = xhr.responseXML\\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\\n            } catch (e) { error = e }\\n\\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\\n          }\\n\\n          ajaxSuccess(result, xhr, settings, deferred)\\n        } else {\\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\\n        }\\n      }\\n    }\\n\\n    if (ajaxBeforeSend(xhr, settings) === false) {\\n      xhr.abort()\\n      ajaxError(null, 'abort', xhr, settings, deferred)\\n      return xhr\\n    }\\n\\n    var async = 'async' in settings ? settings.async : true\\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\\n\\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\\n\\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\\n\\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\\n        xhr.onreadystatechange = empty\\n        xhr.abort()\\n        ajaxError(null, 'timeout', xhr, settings, deferred)\\n      }, settings.timeout)\\n\\n    // avoid sending empty string (#319)\\n    xhr.send(settings.data ? settings.data : null)\\n    return xhr\\n  }\\n\\n  // handle optional data/success arguments\\n  function parseArguments(url, data, success, dataType) {\\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\\n    if (!$.isFunction(success)) dataType = success, success = undefined\\n    return {\\n      url: url\\n    , data: data\\n    , success: success\\n    , dataType: dataType\\n    }\\n  }\\n\\n  $.get = function(/* url, data, success, dataType */){\\n    return $.ajax(parseArguments.apply(null, arguments))\\n  }\\n\\n  $.post = function(/* url, data, success, dataType */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.type = 'POST'\\n    return $.ajax(options)\\n  }\\n\\n  $.getJSON = function(/* url, data, success */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.dataType = 'json'\\n    return $.ajax(options)\\n  }\\n\\n  $.fn.load = function(url, data, success){\\n    if (!this.length) return this\\n    var self = this, parts = url.split(/\\\\s/), selector,\\n        options = parseArguments(url, data, success),\\n        callback = options.success\\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\\n    options.success = function(response){\\n      self.html(selector ?\\n        $('<div>').html(response.replace(rscript, \\\"\\\")).find(selector)\\n        : response)\\n      callback && callback.apply(self, arguments)\\n    }\\n    $.ajax(options)\\n    return this\\n  }\\n\\n  var escape = encodeURIComponent\\n\\n  function serialize(params, obj, traditional, scope){\\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\\n    $.each(obj, function(key, value) {\\n      type = $.type(value)\\n      if (scope) key = traditional ? scope :\\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\\n      // handle data in serializeArray() format\\n      if (!scope && array) params.add(value.name, value.value)\\n      // recurse into nested objects\\n      else if (type == \\\"array\\\" || (!traditional && type == \\\"object\\\"))\\n        serialize(params, value, traditional, key)\\n      else params.add(key, value)\\n    })\\n  }\\n\\n  $.param = function(obj, traditional){\\n    var params = []\\n    params.add = function(key, value) {\\n      if ($.isFunction(value)) value = value()\\n      if (value == null) value = \\\"\\\"\\n      this.push(escape(key) + '=' + escape(value))\\n    }\\n    serialize(params, obj, traditional)\\n    return params.join('&').replace(/%20/g, '+')\\n  }\\n})(Zepto)\\n\\n;(function($){\\n  $.fn.serializeArray = function() {\\n    var name, type, result = [],\\n      add = function(value) {\\n        if (value.forEach) return value.forEach(add)\\n        result.push({ name: name, value: value })\\n      }\\n    if (this[0]) $.each(this[0].elements, function(_, field){\\n      type = field.type, name = field.name\\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\\n        ((type != 'radio' && type != 'checkbox') || field.checked))\\n          add($(field).val())\\n    })\\n    return result\\n  }\\n\\n  $.fn.serialize = function(){\\n    var result = []\\n    this.serializeArray().forEach(function(elm){\\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\\n    })\\n    return result.join('&')\\n  }\\n\\n  $.fn.submit = function(callback) {\\n    if (0 in arguments) this.bind('submit', callback)\\n    else if (this.length) {\\n      var event = $.Event('submit')\\n      this.eq(0).trigger(event)\\n      if (!event.isDefaultPrevented()) this.get(0).submit()\\n    }\\n    return this\\n  }\\n\\n})(Zepto)\\n\\n;(function(){\\n  // getComputedStyle shouldn't freak out when called\\n  // without a valid element as argument\\n  try {\\n    getComputedStyle(undefined)\\n  } catch(e) {\\n    var nativeGetComputedStyle = getComputedStyle\\n    window.getComputedStyle = function(element, pseudoElement){\\n      try {\\n        return nativeGetComputedStyle(element, pseudoElement)\\n      } catch(e) {\\n        return null\\n      }\\n    }\\n  }\\n})()\\n  return Zepto\\n}))\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9femVwdG9AMS4yLjBAemVwdG8vZGlzdC96ZXB0by5qcz9kMDExIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiBaZXB0byB2MS4yLjAgLSB6ZXB0byBldmVudCBhamF4IGZvcm0gaWUgLSB6ZXB0b2pzLmNvbS9saWNlbnNlICovXFxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFjdG9yeShnbG9iYWwpIH0pXFxuICBlbHNlXFxuICAgIGZhY3RvcnkoZ2xvYmFsKVxcbn0odGhpcywgZnVuY3Rpb24od2luZG93KSB7XFxuICB2YXIgWmVwdG8gPSAoZnVuY3Rpb24oKSB7XFxuICB2YXIgdW5kZWZpbmVkLCBrZXksICQsIGNsYXNzTGlzdCwgZW1wdHlBcnJheSA9IFtdLCBjb25jYXQgPSBlbXB0eUFycmF5LmNvbmNhdCwgZmlsdGVyID0gZW1wdHlBcnJheS5maWx0ZXIsIHNsaWNlID0gZW1wdHlBcnJheS5zbGljZSxcXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXFxuICAgIGVsZW1lbnREaXNwbGF5ID0ge30sIGNsYXNzQ2FjaGUgPSB7fSxcXG4gICAgY3NzTnVtYmVyID0geyAnY29sdW1uLWNvdW50JzogMSwgJ2NvbHVtbnMnOiAxLCAnZm9udC13ZWlnaHQnOiAxLCAnbGluZS1oZWlnaHQnOiAxLCdvcGFjaXR5JzogMSwgJ3otaW5kZXgnOiAxLCAnem9vbSc6IDEgfSxcXG4gICAgZnJhZ21lbnRSRSA9IC9eXFxcXHMqPChcXFxcdyt8ISlbXj5dKj4vLFxcbiAgICBzaW5nbGVUYWdSRSA9IC9ePChcXFxcdyspXFxcXHMqXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC8sXFxuICAgIHRhZ0V4cGFuZGVyUkUgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFxcXHc6XSspW14+XSopXFxcXC8+L2lnLFxcbiAgICByb290Tm9kZVJFID0gL14oPzpib2R5fGh0bWwpJC9pLFxcbiAgICBjYXBpdGFsUkUgPSAvKFtBLVpdKS9nLFxcblxcbiAgICAvLyBzcGVjaWFsIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgZ2V0L3NldCB2aWEgbWV0aG9kIGNhbGxzXFxuICAgIG1ldGhvZEF0dHJpYnV0ZXMgPSBbJ3ZhbCcsICdjc3MnLCAnaHRtbCcsICd0ZXh0JywgJ2RhdGEnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ29mZnNldCddLFxcblxcbiAgICBhZGphY2VuY3lPcGVyYXRvcnMgPSBbICdhZnRlcicsICdwcmVwZW5kJywgJ2JlZm9yZScsICdhcHBlbmQnIF0sXFxuICAgIHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKSxcXG4gICAgdGFibGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpLFxcbiAgICBjb250YWluZXJzID0ge1xcbiAgICAgICd0cic6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5JyksXFxuICAgICAgJ3Rib2R5JzogdGFibGUsICd0aGVhZCc6IHRhYmxlLCAndGZvb3QnOiB0YWJsZSxcXG4gICAgICAndGQnOiB0YWJsZVJvdywgJ3RoJzogdGFibGVSb3csXFxuICAgICAgJyonOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxcbiAgICB9LFxcbiAgICByZWFkeVJFID0gL2NvbXBsZXRlfGxvYWRlZHxpbnRlcmFjdGl2ZS8sXFxuICAgIHNpbXBsZVNlbGVjdG9yUkUgPSAvXltcXFxcdy1dKiQvLFxcbiAgICBjbGFzczJ0eXBlID0ge30sXFxuICAgIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZyxcXG4gICAgemVwdG8gPSB7fSxcXG4gICAgY2FtZWxpemUsIHVuaXEsXFxuICAgIHRlbXBQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXG4gICAgcHJvcE1hcCA9IHtcXG4gICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxcbiAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXFxuICAgICAgJ2Zvcic6ICdodG1sRm9yJyxcXG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcXG4gICAgICAnbWF4bGVuZ3RoJzogJ21heExlbmd0aCcsXFxuICAgICAgJ2NlbGxzcGFjaW5nJzogJ2NlbGxTcGFjaW5nJyxcXG4gICAgICAnY2VsbHBhZGRpbmcnOiAnY2VsbFBhZGRpbmcnLFxcbiAgICAgICdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxcbiAgICAgICdjb2xzcGFuJzogJ2NvbFNwYW4nLFxcbiAgICAgICd1c2VtYXAnOiAndXNlTWFwJyxcXG4gICAgICAnZnJhbWVib3JkZXInOiAnZnJhbWVCb3JkZXInLFxcbiAgICAgICdjb250ZW50ZWRpdGFibGUnOiAnY29udGVudEVkaXRhYmxlJ1xcbiAgICB9LFxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxcbiAgICAgIGZ1bmN0aW9uKG9iamVjdCl7IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBBcnJheSB9XFxuXFxuICB6ZXB0by5tYXRjaGVzID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgaWYgKCFzZWxlY3RvciB8fCAhZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSByZXR1cm4gZmFsc2VcXG4gICAgdmFyIG1hdGNoZXNTZWxlY3RvciA9IGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvclxcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpXFxuICAgIC8vIGZhbGwgYmFjayB0byBwZXJmb3JtaW5nIGEgc2VsZWN0b3I6XFxuICAgIHZhciBtYXRjaCwgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLCB0ZW1wID0gIXBhcmVudFxcbiAgICBpZiAodGVtcCkgKHBhcmVudCA9IHRlbXBQYXJlbnQpLmFwcGVuZENoaWxkKGVsZW1lbnQpXFxuICAgIG1hdGNoID0gfnplcHRvLnFzYShwYXJlbnQsIHNlbGVjdG9yKS5pbmRleE9mKGVsZW1lbnQpXFxuICAgIHRlbXAgJiYgdGVtcFBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KVxcbiAgICByZXR1cm4gbWF0Y2hcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHR5cGUob2JqKSB7XFxuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IFN0cmluZyhvYmopIDpcXG4gICAgICBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXFxcIm9iamVjdFxcXCJcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHR5cGUodmFsdWUpID09IFxcXCJmdW5jdGlvblxcXCIgfVxcbiAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSAgICAgeyByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3cgfVxcbiAgZnVuY3Rpb24gaXNEb2N1bWVudChvYmopICAgeyByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqLm5vZGVUeXBlID09IG9iai5ET0NVTUVOVF9OT0RFIH1cXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgICAgIHsgcmV0dXJuIHR5cGUob2JqKSA9PSBcXFwib2JqZWN0XFxcIiB9XFxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiAhaXNXaW5kb3cob2JqKSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlXFxuICB9XFxuXFxuICBmdW5jdGlvbiBsaWtlQXJyYXkob2JqKSB7XFxuICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiAnbGVuZ3RoJyBpbiBvYmogJiYgb2JqLmxlbmd0aCxcXG4gICAgICB0eXBlID0gJC50eXBlKG9iailcXG5cXG4gICAgcmV0dXJuICdmdW5jdGlvbicgIT0gdHlwZSAmJiAhaXNXaW5kb3cob2JqKSAmJiAoXFxuICAgICAgJ2FycmF5JyA9PSB0eXBlIHx8IGxlbmd0aCA9PT0gMCB8fFxcbiAgICAgICAgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqKVxcbiAgICApXFxuICB9XFxuXFxuICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7IHJldHVybiBmaWx0ZXIuY2FsbChhcnJheSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtICE9IG51bGwgfSkgfVxcbiAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkgeyByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/ICQuZm4uY29uY2F0LmFwcGx5KFtdLCBhcnJheSkgOiBhcnJheSB9XFxuICBjYW1lbGl6ZSA9IGZ1bmN0aW9uKHN0cil7IHJldHVybiBzdHIucmVwbGFjZSgvLSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjaHIpeyByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJyB9KSB9XFxuICBmdW5jdGlvbiBkYXNoZXJpemUoc3RyKSB7XFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvOjovZywgJy8nKVxcbiAgICAgICAgICAgLnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2Etel0pL2csICckMV8kMicpXFxuICAgICAgICAgICAucmVwbGFjZSgvKFthLXpcXFxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKVxcbiAgICAgICAgICAgLnJlcGxhY2UoL18vZywgJy0nKVxcbiAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcXG4gIH1cXG4gIHVuaXEgPSBmdW5jdGlvbihhcnJheSl7IHJldHVybiBmaWx0ZXIuY2FsbChhcnJheSwgZnVuY3Rpb24oaXRlbSwgaWR4KXsgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgPT0gaWR4IH0pIH1cXG5cXG4gIGZ1bmN0aW9uIGNsYXNzUkUobmFtZSkge1xcbiAgICByZXR1cm4gbmFtZSBpbiBjbGFzc0NhY2hlID9cXG4gICAgICBjbGFzc0NhY2hlW25hbWVdIDogKGNsYXNzQ2FjaGVbbmFtZV0gPSBuZXcgUmVnRXhwKCcoXnxcXFxcXFxcXHMpJyArIG5hbWUgKyAnKFxcXFxcXFxcc3wkKScpKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWF5YmVBZGRQeChuYW1lLCB2YWx1ZSkge1xcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PSBcXFwibnVtYmVyXFxcIiAmJiAhY3NzTnVtYmVyW2Rhc2hlcml6ZShuYW1lKV0pID8gdmFsdWUgKyBcXFwicHhcXFwiIDogdmFsdWVcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KG5vZGVOYW1lKSB7XFxuICAgIHZhciBlbGVtZW50LCBkaXNwbGF5XFxuICAgIGlmICghZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdKSB7XFxuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpXFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KVxcbiAgICAgIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFxcXCJkaXNwbGF5XFxcIilcXG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudClcXG4gICAgICBkaXNwbGF5ID09IFxcXCJub25lXFxcIiAmJiAoZGlzcGxheSA9IFxcXCJibG9ja1xcXCIpXFxuICAgICAgZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdID0gZGlzcGxheVxcbiAgICB9XFxuICAgIHJldHVybiBlbGVtZW50RGlzcGxheVtub2RlTmFtZV1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuICdjaGlsZHJlbicgaW4gZWxlbWVudCA/XFxuICAgICAgc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkcmVuKSA6XFxuICAgICAgJC5tYXAoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKXsgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkgcmV0dXJuIG5vZGUgfSlcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIFooZG9tLCBzZWxlY3Rvcikge1xcbiAgICB2YXIgaSwgbGVuID0gZG9tID8gZG9tLmxlbmd0aCA6IDBcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzW2ldID0gZG9tW2ldXFxuICAgIHRoaXMubGVuZ3RoID0gbGVuXFxuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJ1xcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8uZnJhZ21lbnRgIHRha2VzIGEgaHRtbCBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHRhZyBuYW1lXFxuICAvLyB0byBnZW5lcmF0ZSBET00gbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcuXFxuICAvLyBUaGUgZ2VuZXJhdGVkIERPTSBub2RlcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkuXFxuICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMgZm9yIGV4YW1wbGUgdG8gbWFrZVxcbiAgLy8gaXQgY29tcGF0aWJsZSB3aXRoIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgRE9NIGZ1bGx5LlxcbiAgemVwdG8uZnJhZ21lbnQgPSBmdW5jdGlvbihodG1sLCBuYW1lLCBwcm9wZXJ0aWVzKSB7XFxuICAgIHZhciBkb20sIG5vZGVzLCBjb250YWluZXJcXG5cXG4gICAgLy8gQSBzcGVjaWFsIGNhc2Ugb3B0aW1pemF0aW9uIGZvciBhIHNpbmdsZSB0YWdcXG4gICAgaWYgKHNpbmdsZVRhZ1JFLnRlc3QoaHRtbCkpIGRvbSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChSZWdFeHAuJDEpKVxcblxcbiAgICBpZiAoIWRvbSkge1xcbiAgICAgIGlmIChodG1sLnJlcGxhY2UpIGh0bWwgPSBodG1sLnJlcGxhY2UodGFnRXhwYW5kZXJSRSwgXFxcIjwkMT48LyQyPlxcXCIpXFxuICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgbmFtZSA9IGZyYWdtZW50UkUudGVzdChodG1sKSAmJiBSZWdFeHAuJDFcXG4gICAgICBpZiAoIShuYW1lIGluIGNvbnRhaW5lcnMpKSBuYW1lID0gJyonXFxuXFxuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyc1tuYW1lXVxcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJyArIGh0bWxcXG4gICAgICBkb20gPSAkLmVhY2goc2xpY2UuY2FsbChjb250YWluZXIuY2hpbGROb2RlcyksIGZ1bmN0aW9uKCl7XFxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcylcXG4gICAgICB9KVxcbiAgICB9XFxuXFxuICAgIGlmIChpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSB7XFxuICAgICAgbm9kZXMgPSAkKGRvbSlcXG4gICAgICAkLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKG1ldGhvZEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpID4gLTEpIG5vZGVzW2tleV0odmFsdWUpXFxuICAgICAgICBlbHNlIG5vZGVzLmF0dHIoa2V5LCB2YWx1ZSlcXG4gICAgICB9KVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBkb21cXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLlpgIHN3YXBzIG91dCB0aGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBgZG9tYCBhcnJheVxcbiAgLy8gb2Ygbm9kZXMgd2l0aCBgJC5mbmAgYW5kIHRodXMgc3VwcGx5aW5nIGFsbCB0aGUgWmVwdG8gZnVuY3Rpb25zXFxuICAvLyB0byB0aGUgYXJyYXkuIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXFxuICB6ZXB0by5aID0gZnVuY3Rpb24oZG9tLCBzZWxlY3Rvcikge1xcbiAgICByZXR1cm4gbmV3IFooZG9tLCBzZWxlY3RvcilcXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLmlzWmAgc2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIFplcHRvXFxuICAvLyBjb2xsZWN0aW9uLiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxcbiAgemVwdG8uaXNaID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB6ZXB0by5aXFxuICB9XFxuXFxuICAvLyBgJC56ZXB0by5pbml0YCBpcyBaZXB0bydzIGNvdW50ZXJwYXJ0IHRvIGpRdWVyeSdzIGAkLmZuLmluaXRgIGFuZFxcbiAgLy8gdGFrZXMgYSBDU1Mgc2VsZWN0b3IgYW5kIGFuIG9wdGlvbmFsIGNvbnRleHQgKGFuZCBoYW5kbGVzIHZhcmlvdXNcXG4gIC8vIHNwZWNpYWwgY2FzZXMpLlxcbiAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cXG4gIHplcHRvLmluaXQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xcbiAgICB2YXIgZG9tXFxuICAgIC8vIElmIG5vdGhpbmcgZ2l2ZW4sIHJldHVybiBhbiBlbXB0eSBaZXB0byBjb2xsZWN0aW9uXFxuICAgIGlmICghc2VsZWN0b3IpIHJldHVybiB6ZXB0by5aKClcXG4gICAgLy8gT3B0aW1pemUgZm9yIHN0cmluZyBzZWxlY3RvcnNcXG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnKSB7XFxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKClcXG4gICAgICAvLyBJZiBpdCdzIGEgaHRtbCBmcmFnbWVudCwgY3JlYXRlIG5vZGVzIGZyb20gaXRcXG4gICAgICAvLyBOb3RlOiBJbiBib3RoIENocm9tZSAyMSBhbmQgRmlyZWZveCAxNSwgRE9NIGVycm9yIDEyXFxuICAgICAgLy8gaXMgdGhyb3duIGlmIHRoZSBmcmFnbWVudCBkb2Vzbid0IGJlZ2luIHdpdGggPFxcbiAgICAgIGlmIChzZWxlY3RvclswXSA9PSAnPCcgJiYgZnJhZ21lbnRSRS50ZXN0KHNlbGVjdG9yKSlcXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgY29udGV4dCwgY3JlYXRlIGEgY29sbGVjdGlvbiBvbiB0aGF0IGNvbnRleHQgZmlyc3QsIGFuZCBzZWxlY3RcXG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXFxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxcbiAgICAgIC8vIElmIGl0J3MgYSBDU1Mgc2VsZWN0b3IsIHVzZSBpdCB0byBzZWxlY3Qgbm9kZXMuXFxuICAgICAgZWxzZSBkb20gPSB6ZXB0by5xc2EoZG9jdW1lbnQsIHNlbGVjdG9yKVxcbiAgICB9XFxuICAgIC8vIElmIGEgZnVuY3Rpb24gaXMgZ2l2ZW4sIGNhbGwgaXQgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSByZXR1cm4gJChkb2N1bWVudCkucmVhZHkoc2VsZWN0b3IpXFxuICAgIC8vIElmIGEgWmVwdG8gY29sbGVjdGlvbiBpcyBnaXZlbiwganVzdCByZXR1cm4gaXRcXG4gICAgZWxzZSBpZiAoemVwdG8uaXNaKHNlbGVjdG9yKSkgcmV0dXJuIHNlbGVjdG9yXFxuICAgIGVsc2Uge1xcbiAgICAgIC8vIG5vcm1hbGl6ZSBhcnJheSBpZiBhbiBhcnJheSBvZiBub2RlcyBpcyBnaXZlblxcbiAgICAgIGlmIChpc0FycmF5KHNlbGVjdG9yKSkgZG9tID0gY29tcGFjdChzZWxlY3RvcilcXG4gICAgICAvLyBXcmFwIERPTSBub2Rlcy5cXG4gICAgICBlbHNlIGlmIChpc09iamVjdChzZWxlY3RvcikpXFxuICAgICAgICBkb20gPSBbc2VsZWN0b3JdLCBzZWxlY3RvciA9IG51bGxcXG4gICAgICAvLyBJZiBpdCdzIGEgaHRtbCBmcmFnbWVudCwgY3JlYXRlIG5vZGVzIGZyb20gaXRcXG4gICAgICBlbHNlIGlmIChmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxcbiAgICAgICAgZG9tID0gemVwdG8uZnJhZ21lbnQoc2VsZWN0b3IudHJpbSgpLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgY29udGV4dCwgY3JlYXRlIGEgY29sbGVjdGlvbiBvbiB0aGF0IGNvbnRleHQgZmlyc3QsIGFuZCBzZWxlY3RcXG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXFxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxcbiAgICAgIC8vIEFuZCBsYXN0IGJ1dCBubyBsZWFzdCwgaWYgaXQncyBhIENTUyBzZWxlY3RvciwgdXNlIGl0IHRvIHNlbGVjdCBub2Rlcy5cXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXFxuICAgIH1cXG4gICAgLy8gY3JlYXRlIGEgbmV3IFplcHRvIGNvbGxlY3Rpb24gZnJvbSB0aGUgbm9kZXMgZm91bmRcXG4gICAgcmV0dXJuIHplcHRvLlooZG9tLCBzZWxlY3RvcilcXG4gIH1cXG5cXG4gIC8vIGAkYCB3aWxsIGJlIHRoZSBiYXNlIGBaZXB0b2Agb2JqZWN0LiBXaGVuIGNhbGxpbmcgdGhpc1xcbiAgLy8gZnVuY3Rpb24ganVzdCBjYWxsIGAkLnplcHRvLmluaXQsIHdoaWNoIG1ha2VzIHRoZSBpbXBsZW1lbnRhdGlvblxcbiAgLy8gZGV0YWlscyBvZiBzZWxlY3Rpbmcgbm9kZXMgYW5kIGNyZWF0aW5nIFplcHRvIGNvbGxlY3Rpb25zXFxuICAvLyBwYXRjaGFibGUgaW4gcGx1Z2lucy5cXG4gICQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCl7XFxuICAgIHJldHVybiB6ZXB0by5pbml0KHNlbGVjdG9yLCBjb250ZXh0KVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XFxuICAgIGZvciAoa2V5IGluIHNvdXJjZSlcXG4gICAgICBpZiAoZGVlcCAmJiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgfHwgaXNBcnJheShzb3VyY2Vba2V5XSkpKSB7XFxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIWlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKVxcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9XFxuICAgICAgICBpZiAoaXNBcnJheShzb3VyY2Vba2V5XSkgJiYgIWlzQXJyYXkodGFyZ2V0W2tleV0pKVxcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdXFxuICAgICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKVxcbiAgICAgIH1cXG4gICAgICBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXFxuICB9XFxuXFxuICAvLyBDb3B5IGFsbCBidXQgdW5kZWZpbmVkIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZVxcbiAgLy8gb2JqZWN0cyB0byB0aGUgYHRhcmdldGAgb2JqZWN0LlxcbiAgJC5leHRlbmQgPSBmdW5jdGlvbih0YXJnZXQpe1xcbiAgICB2YXIgZGVlcCwgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcXG4gICAgICBkZWVwID0gdGFyZ2V0XFxuICAgICAgdGFyZ2V0ID0gYXJncy5zaGlmdCgpXFxuICAgIH1cXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7IGV4dGVuZCh0YXJnZXQsIGFyZywgZGVlcCkgfSlcXG4gICAgcmV0dXJuIHRhcmdldFxcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8ucXNhYCBpcyBaZXB0bydzIENTUyBzZWxlY3RvciBpbXBsZW1lbnRhdGlvbiB3aGljaFxcbiAgLy8gdXNlcyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGAgYW5kIG9wdGltaXplcyBmb3Igc29tZSBzcGVjaWFsIGNhc2VzLCBsaWtlIGAjaWRgLlxcbiAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cXG4gIHplcHRvLnFzYSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlbGVjdG9yKXtcXG4gICAgdmFyIGZvdW5kLFxcbiAgICAgICAgbWF5YmVJRCA9IHNlbGVjdG9yWzBdID09ICcjJyxcXG4gICAgICAgIG1heWJlQ2xhc3MgPSAhbWF5YmVJRCAmJiBzZWxlY3RvclswXSA9PSAnLicsXFxuICAgICAgICBuYW1lT25seSA9IG1heWJlSUQgfHwgbWF5YmVDbGFzcyA/IHNlbGVjdG9yLnNsaWNlKDEpIDogc2VsZWN0b3IsIC8vIEVuc3VyZSB0aGF0IGEgMSBjaGFyIHRhZyBuYW1lIHN0aWxsIGdldHMgY2hlY2tlZFxcbiAgICAgICAgaXNTaW1wbGUgPSBzaW1wbGVTZWxlY3RvclJFLnRlc3QobmFtZU9ubHkpXFxuICAgIHJldHVybiAoZWxlbWVudC5nZXRFbGVtZW50QnlJZCAmJiBpc1NpbXBsZSAmJiBtYXliZUlEKSA/IC8vIFNhZmFyaSBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50QnlJZFxcbiAgICAgICggKGZvdW5kID0gZWxlbWVudC5nZXRFbGVtZW50QnlJZChuYW1lT25seSkpID8gW2ZvdW5kXSA6IFtdICkgOlxcbiAgICAgIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IDkgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gMTEpID8gW10gOlxcbiAgICAgIHNsaWNlLmNhbGwoXFxuICAgICAgICBpc1NpbXBsZSAmJiAhbWF5YmVJRCAmJiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPyAvLyBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lL1RhZ05hbWVcXG4gICAgICAgICAgbWF5YmVDbGFzcyA/IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lT25seSkgOiAvLyBJZiBpdCdzIHNpbXBsZSwgaXQgY291bGQgYmUgYSBjbGFzc1xcbiAgICAgICAgICBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSA6IC8vIE9yIGEgdGFnXFxuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgLy8gT3IgaXQncyBub3Qgc2ltcGxlLCBhbmQgd2UgbmVlZCB0byBxdWVyeSBhbGxcXG4gICAgICApXFxuICB9XFxuXFxuICBmdW5jdGlvbiBmaWx0ZXJlZChub2Rlcywgc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyAkKG5vZGVzKSA6ICQobm9kZXMpLmZpbHRlcihzZWxlY3RvcilcXG4gIH1cXG5cXG4gICQuY29udGFpbnMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgP1xcbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcXG4gICAgICByZXR1cm4gcGFyZW50ICE9PSBub2RlICYmIHBhcmVudC5jb250YWlucyhub2RlKVxcbiAgICB9IDpcXG4gICAgZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XFxuICAgICAgd2hpbGUgKG5vZGUgJiYgKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKVxcbiAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudCkgcmV0dXJuIHRydWVcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gICAgfVxcblxcbiAgZnVuY3Rpb24gZnVuY0FyZyhjb250ZXh0LCBhcmcsIGlkeCwgcGF5bG9hZCkge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmcpID8gYXJnLmNhbGwoY29udGV4dCwgaWR4LCBwYXlsb2FkKSA6IGFyZ1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XFxuICAgIHZhbHVlID09IG51bGwgPyBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSA6IG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxcbiAgfVxcblxcbiAgLy8gYWNjZXNzIGNsYXNzTmFtZSBwcm9wZXJ0eSB3aGlsZSByZXNwZWN0aW5nIFNWR0FuaW1hdGVkU3RyaW5nXFxuICBmdW5jdGlvbiBjbGFzc05hbWUobm9kZSwgdmFsdWUpe1xcbiAgICB2YXIga2xhc3MgPSBub2RlLmNsYXNzTmFtZSB8fCAnJyxcXG4gICAgICAgIHN2ZyAgID0ga2xhc3MgJiYga2xhc3MuYmFzZVZhbCAhPT0gdW5kZWZpbmVkXFxuXFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gc3ZnID8ga2xhc3MuYmFzZVZhbCA6IGtsYXNzXFxuICAgIHN2ZyA/IChrbGFzcy5iYXNlVmFsID0gdmFsdWUpIDogKG5vZGUuY2xhc3NOYW1lID0gdmFsdWUpXFxuICB9XFxuXFxuICAvLyBcXFwidHJ1ZVxcXCIgID0+IHRydWVcXG4gIC8vIFxcXCJmYWxzZVxcXCIgPT4gZmFsc2VcXG4gIC8vIFxcXCJudWxsXFxcIiAgPT4gbnVsbFxcbiAgLy8gXFxcIjQyXFxcIiAgICA9PiA0MlxcbiAgLy8gXFxcIjQyLjVcXFwiICA9PiA0Mi41XFxuICAvLyBcXFwiMDhcXFwiICAgID0+IFxcXCIwOFxcXCJcXG4gIC8vIEpTT04gICAgPT4gcGFyc2UgaWYgdmFsaWRcXG4gIC8vIFN0cmluZyAgPT4gc2VsZlxcbiAgZnVuY3Rpb24gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA/XFxuICAgICAgICB2YWx1ZSA9PSBcXFwidHJ1ZVxcXCIgfHxcXG4gICAgICAgICggdmFsdWUgPT0gXFxcImZhbHNlXFxcIiA/IGZhbHNlIDpcXG4gICAgICAgICAgdmFsdWUgPT0gXFxcIm51bGxcXFwiID8gbnVsbCA6XFxuICAgICAgICAgICt2YWx1ZSArIFxcXCJcXFwiID09IHZhbHVlID8gK3ZhbHVlIDpcXG4gICAgICAgICAgL15bXFxcXFtcXFxce10vLnRlc3QodmFsdWUpID8gJC5wYXJzZUpTT04odmFsdWUpIDpcXG4gICAgICAgICAgdmFsdWUgKVxcbiAgICAgICAgOiB2YWx1ZVxcbiAgICB9IGNhdGNoKGUpIHtcXG4gICAgICByZXR1cm4gdmFsdWVcXG4gICAgfVxcbiAgfVxcblxcbiAgJC50eXBlID0gdHlwZVxcbiAgJC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvblxcbiAgJC5pc1dpbmRvdyA9IGlzV2luZG93XFxuICAkLmlzQXJyYXkgPSBpc0FycmF5XFxuICAkLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0XFxuXFxuICAkLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcXG4gICAgdmFyIG5hbWVcXG4gICAgZm9yIChuYW1lIGluIG9iaikgcmV0dXJuIGZhbHNlXFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuXFxuICAkLmlzTnVtZXJpYyA9IGZ1bmN0aW9uKHZhbCkge1xcbiAgICB2YXIgbnVtID0gTnVtYmVyKHZhbCksIHR5cGUgPSB0eXBlb2YgdmFsXFxuICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlICE9ICdib29sZWFuJyAmJlxcbiAgICAgICh0eXBlICE9ICdzdHJpbmcnIHx8IHZhbC5sZW5ndGgpICYmXFxuICAgICAgIWlzTmFOKG51bSkgJiYgaXNGaW5pdGUobnVtKSB8fCBmYWxzZVxcbiAgfVxcblxcbiAgJC5pbkFycmF5ID0gZnVuY3Rpb24oZWxlbSwgYXJyYXksIGkpe1xcbiAgICByZXR1cm4gZW1wdHlBcnJheS5pbmRleE9mLmNhbGwoYXJyYXksIGVsZW0sIGkpXFxuICB9XFxuXFxuICAkLmNhbWVsQ2FzZSA9IGNhbWVsaXplXFxuICAkLnRyaW0gPSBmdW5jdGlvbihzdHIpIHtcXG4gICAgcmV0dXJuIHN0ciA9PSBudWxsID8gXFxcIlxcXCIgOiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXFxuICB9XFxuXFxuICAvLyBwbHVnaW4gY29tcGF0aWJpbGl0eVxcbiAgJC51dWlkID0gMFxcbiAgJC5zdXBwb3J0ID0geyB9XFxuICAkLmV4cHIgPSB7IH1cXG4gICQubm9vcCA9IGZ1bmN0aW9uKCkge31cXG5cXG4gICQubWFwID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcXG4gICAgdmFyIHZhbHVlLCB2YWx1ZXMgPSBbXSwgaSwga2V5XFxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKVxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1tpXSwgaSlcXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcXG4gICAgICB9XFxuICAgIGVsc2VcXG4gICAgICBmb3IgKGtleSBpbiBlbGVtZW50cykge1xcbiAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1trZXldLCBrZXkpXFxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWVzLnB1c2godmFsdWUpXFxuICAgICAgfVxcbiAgICByZXR1cm4gZmxhdHRlbih2YWx1ZXMpXFxuICB9XFxuXFxuICAkLmVhY2ggPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xcbiAgICB2YXIgaSwga2V5XFxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoZWxlbWVudHNbaV0sIGksIGVsZW1lbnRzW2ldKSA9PT0gZmFsc2UpIHJldHVybiBlbGVtZW50c1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoa2V5IGluIGVsZW1lbnRzKVxcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoZWxlbWVudHNba2V5XSwga2V5LCBlbGVtZW50c1trZXldKSA9PT0gZmFsc2UpIHJldHVybiBlbGVtZW50c1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBlbGVtZW50c1xcbiAgfVxcblxcbiAgJC5ncmVwID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjaylcXG4gIH1cXG5cXG4gIGlmICh3aW5kb3cuSlNPTikgJC5wYXJzZUpTT04gPSBKU09OLnBhcnNlXFxuXFxuICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcXG4gICQuZWFjaChcXFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xcbiAgICBjbGFzczJ0eXBlWyBcXFwiW29iamVjdCBcXFwiICsgbmFtZSArIFxcXCJdXFxcIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpXFxuICB9KVxcblxcbiAgLy8gRGVmaW5lIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBhbGxcXG4gIC8vIFplcHRvIGNvbGxlY3Rpb25zXFxuICAkLmZuID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogemVwdG8uWixcXG4gICAgbGVuZ3RoOiAwLFxcblxcbiAgICAvLyBCZWNhdXNlIGEgY29sbGVjdGlvbiBhY3RzIGxpa2UgYW4gYXJyYXlcXG4gICAgLy8gY29weSBvdmVyIHRoZXNlIHVzZWZ1bCBhcnJheSBmdW5jdGlvbnMuXFxuICAgIGZvckVhY2g6IGVtcHR5QXJyYXkuZm9yRWFjaCxcXG4gICAgcmVkdWNlOiBlbXB0eUFycmF5LnJlZHVjZSxcXG4gICAgcHVzaDogZW1wdHlBcnJheS5wdXNoLFxcbiAgICBzb3J0OiBlbXB0eUFycmF5LnNvcnQsXFxuICAgIHNwbGljZTogZW1wdHlBcnJheS5zcGxpY2UsXFxuICAgIGluZGV4T2Y6IGVtcHR5QXJyYXkuaW5kZXhPZixcXG4gICAgY29uY2F0OiBmdW5jdGlvbigpe1xcbiAgICAgIHZhciBpLCB2YWx1ZSwgYXJncyA9IFtdXFxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbaV1cXG4gICAgICAgIGFyZ3NbaV0gPSB6ZXB0by5pc1oodmFsdWUpID8gdmFsdWUudG9BcnJheSgpIDogdmFsdWVcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseSh6ZXB0by5pc1oodGhpcykgPyB0aGlzLnRvQXJyYXkoKSA6IHRoaXMsIGFyZ3MpXFxuICAgIH0sXFxuXFxuICAgIC8vIGBtYXBgIGFuZCBgc2xpY2VgIGluIHRoZSBqUXVlcnkgQVBJIHdvcmsgZGlmZmVyZW50bHlcXG4gICAgLy8gZnJvbSB0aGVpciBhcnJheSBjb3VudGVycGFydHNcXG4gICAgbWFwOiBmdW5jdGlvbihmbil7XFxuICAgICAgcmV0dXJuICQoJC5tYXAodGhpcywgZnVuY3Rpb24oZWwsIGkpeyByZXR1cm4gZm4uY2FsbChlbCwgaSwgZWwpIH0pKVxcbiAgICB9LFxcbiAgICBzbGljZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gJChzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxcbiAgICB9LFxcblxcbiAgICByZWFkeTogZnVuY3Rpb24oY2FsbGJhY2spe1xcbiAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgZG9jdW1lbnQuYm9keSBleGlzdHMgZm9yIElFIGFzIHRoYXQgYnJvd3NlciByZXBvcnRzXFxuICAgICAgLy8gZG9jdW1lbnQgcmVhZHkgd2hlbiBpdCBoYXNuJ3QgeWV0IGNyZWF0ZWQgdGhlIGJvZHkgZWxlbWVudFxcbiAgICAgIGlmIChyZWFkeVJFLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkgJiYgZG9jdW1lbnQuYm9keSkgY2FsbGJhY2soJClcXG4gICAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpeyBjYWxsYmFjaygkKSB9LCBmYWxzZSlcXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBnZXQ6IGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgcmV0dXJuIGlkeCA9PT0gdW5kZWZpbmVkID8gc2xpY2UuY2FsbCh0aGlzKSA6IHRoaXNbaWR4ID49IDAgPyBpZHggOiBpZHggKyB0aGlzLmxlbmd0aF1cXG4gICAgfSxcXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0KCkgfSxcXG4gICAgc2l6ZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGhcXG4gICAgfSxcXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgIT0gbnVsbClcXG4gICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgZWFjaDogZnVuY3Rpb24oY2FsbGJhY2spe1xcbiAgICAgIGVtcHR5QXJyYXkuZXZlcnkuY2FsbCh0aGlzLCBmdW5jdGlvbihlbCwgaWR4KXtcXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsLCBpZHgsIGVsKSAhPT0gZmFsc2VcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuIHRoaXMubm90KHRoaXMubm90KHNlbGVjdG9yKSlcXG4gICAgICByZXR1cm4gJChmaWx0ZXIuY2FsbCh0aGlzLCBmdW5jdGlvbihlbGVtZW50KXtcXG4gICAgICAgIHJldHVybiB6ZXB0by5tYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKVxcbiAgICAgIH0pKVxcbiAgICB9LFxcbiAgICBhZGQ6IGZ1bmN0aW9uKHNlbGVjdG9yLGNvbnRleHQpe1xcbiAgICAgIHJldHVybiAkKHVuaXEodGhpcy5jb25jYXQoJChzZWxlY3Rvcixjb250ZXh0KSkpKVxcbiAgICB9LFxcbiAgICBpczogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgemVwdG8ubWF0Y2hlcyh0aGlzWzBdLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgbm90OiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgdmFyIG5vZGVzPVtdXFxuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpICYmIHNlbGVjdG9yLmNhbGwgIT09IHVuZGVmaW5lZClcXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yLmNhbGwodGhpcyxpZHgpKSBub2Rlcy5wdXNoKHRoaXMpXFxuICAgICAgICB9KVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgdmFyIGV4Y2x1ZGVzID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gdGhpcy5maWx0ZXIoc2VsZWN0b3IpIDpcXG4gICAgICAgICAgKGxpa2VBcnJheShzZWxlY3RvcikgJiYgaXNGdW5jdGlvbihzZWxlY3Rvci5pdGVtKSkgPyBzbGljZS5jYWxsKHNlbGVjdG9yKSA6ICQoc2VsZWN0b3IpXFxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xcbiAgICAgICAgICBpZiAoZXhjbHVkZXMuaW5kZXhPZihlbCkgPCAwKSBub2Rlcy5wdXNoKGVsKVxcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICAgcmV0dXJuICQobm9kZXMpXFxuICAgIH0sXFxuICAgIGhhczogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe1xcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHNlbGVjdG9yKSA/XFxuICAgICAgICAgICQuY29udGFpbnModGhpcywgc2VsZWN0b3IpIDpcXG4gICAgICAgICAgJCh0aGlzKS5maW5kKHNlbGVjdG9yKS5zaXplKClcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBlcTogZnVuY3Rpb24oaWR4KXtcXG4gICAgICByZXR1cm4gaWR4ID09PSAtMSA/IHRoaXMuc2xpY2UoaWR4KSA6IHRoaXMuc2xpY2UoaWR4LCArIGlkeCArIDEpXFxuICAgIH0sXFxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xcbiAgICAgIHZhciBlbCA9IHRoaXNbMF1cXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcXG4gICAgfSxcXG4gICAgbGFzdDogZnVuY3Rpb24oKXtcXG4gICAgICB2YXIgZWwgPSB0aGlzW3RoaXMubGVuZ3RoIC0gMV1cXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcXG4gICAgfSxcXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHZhciByZXN1bHQsICR0aGlzID0gdGhpc1xcbiAgICAgIGlmICghc2VsZWN0b3IpIHJlc3VsdCA9ICQoKVxcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PSAnb2JqZWN0JylcXG4gICAgICAgIHJlc3VsdCA9ICQoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpe1xcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXNcXG4gICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXkuc29tZS5jYWxsKCR0aGlzLCBmdW5jdGlvbihwYXJlbnQpe1xcbiAgICAgICAgICAgIHJldHVybiAkLmNvbnRhaW5zKHBhcmVudCwgbm9kZSlcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT0gMSkgcmVzdWx0ID0gJCh6ZXB0by5xc2EodGhpc1swXSwgc2VsZWN0b3IpKVxcbiAgICAgIGVsc2UgcmVzdWx0ID0gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHplcHRvLnFzYSh0aGlzLCBzZWxlY3RvcikgfSlcXG4gICAgICByZXR1cm4gcmVzdWx0XFxuICAgIH0sXFxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcXG4gICAgICB2YXIgbm9kZXMgPSBbXSwgY29sbGVjdGlvbiA9IHR5cGVvZiBzZWxlY3RvciA9PSAnb2JqZWN0JyAmJiAkKHNlbGVjdG9yKVxcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihfLCBub2RlKXtcXG4gICAgICAgIHdoaWxlIChub2RlICYmICEoY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24uaW5kZXhPZihub2RlKSA+PSAwIDogemVwdG8ubWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpKVxcbiAgICAgICAgICBub2RlID0gbm9kZSAhPT0gY29udGV4dCAmJiAhaXNEb2N1bWVudChub2RlKSAmJiBub2RlLnBhcmVudE5vZGVcXG4gICAgICAgIGlmIChub2RlICYmIG5vZGVzLmluZGV4T2Yobm9kZSkgPCAwKSBub2Rlcy5wdXNoKG5vZGUpXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gJChub2RlcylcXG4gICAgfSxcXG4gICAgcGFyZW50czogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSwgbm9kZXMgPSB0aGlzXFxuICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDApXFxuICAgICAgICBub2RlcyA9ICQubWFwKG5vZGVzLCBmdW5jdGlvbihub2RlKXtcXG4gICAgICAgICAgaWYgKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSAmJiAhaXNEb2N1bWVudChub2RlKSAmJiBhbmNlc3RvcnMuaW5kZXhPZihub2RlKSA8IDApIHtcXG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKVxcbiAgICAgICAgICAgIHJldHVybiBub2RlXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuICAgICAgcmV0dXJuIGZpbHRlcmVkKGFuY2VzdG9ycywgc2VsZWN0b3IpXFxuICAgIH0sXFxuICAgIHBhcmVudDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh1bmlxKHRoaXMucGx1Y2soJ3BhcmVudE5vZGUnKSksIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gY2hpbGRyZW4odGhpcykgfSksIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBjb250ZW50czogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZW50RG9jdW1lbnQgfHwgc2xpY2UuY2FsbCh0aGlzLmNoaWxkTm9kZXMpIH0pXFxuICAgIH0sXFxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKGksIGVsKXtcXG4gICAgICAgIHJldHVybiBmaWx0ZXIuY2FsbChjaGlsZHJlbihlbC5wYXJlbnROb2RlKSwgZnVuY3Rpb24oY2hpbGQpeyByZXR1cm4gY2hpbGQhPT1lbCB9KVxcbiAgICAgIH0pLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLmlubmVySFRNTCA9ICcnIH0pXFxuICAgIH0sXFxuICAgIC8vIGBwbHVja2AgaXMgYm9ycm93ZWQgZnJvbSBQcm90b3R5cGUuanNcXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKHByb3BlcnR5KXtcXG4gICAgICByZXR1cm4gJC5tYXAodGhpcywgZnVuY3Rpb24oZWwpeyByZXR1cm4gZWxbcHJvcGVydHldIH0pXFxuICAgIH0sXFxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID09IFxcXCJub25lXFxcIiAmJiAodGhpcy5zdHlsZS5kaXNwbGF5ID0gJycpXFxuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCAnJykuZ2V0UHJvcGVydHlWYWx1ZShcXFwiZGlzcGxheVxcXCIpID09IFxcXCJub25lXFxcIilcXG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gZGVmYXVsdERpc3BsYXkodGhpcy5ub2RlTmFtZSlcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24obmV3Q29udGVudCl7XFxuICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlKG5ld0NvbnRlbnQpLnJlbW92ZSgpXFxuICAgIH0sXFxuICAgIHdyYXA6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XFxuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmN0aW9uKHN0cnVjdHVyZSlcXG4gICAgICBpZiAodGhpc1swXSAmJiAhZnVuYylcXG4gICAgICAgIHZhciBkb20gICA9ICQoc3RydWN0dXJlKS5nZXQoMCksXFxuICAgICAgICAgICAgY2xvbmUgPSBkb20ucGFyZW50Tm9kZSB8fCB0aGlzLmxlbmd0aCA+IDFcXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcXG4gICAgICAgICQodGhpcykud3JhcEFsbChcXG4gICAgICAgICAgZnVuYyA/IHN0cnVjdHVyZS5jYWxsKHRoaXMsIGluZGV4KSA6XFxuICAgICAgICAgICAgY2xvbmUgPyBkb20uY2xvbmVOb2RlKHRydWUpIDogZG9tXFxuICAgICAgICApXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgd3JhcEFsbDogZnVuY3Rpb24oc3RydWN0dXJlKXtcXG4gICAgICBpZiAodGhpc1swXSkge1xcbiAgICAgICAgJCh0aGlzWzBdKS5iZWZvcmUoc3RydWN0dXJlID0gJChzdHJ1Y3R1cmUpKVxcbiAgICAgICAgdmFyIGNoaWxkcmVuXFxuICAgICAgICAvLyBkcmlsbCBkb3duIHRvIHRoZSBpbm1vc3QgZWxlbWVudFxcbiAgICAgICAgd2hpbGUgKChjaGlsZHJlbiA9IHN0cnVjdHVyZS5jaGlsZHJlbigpKS5sZW5ndGgpIHN0cnVjdHVyZSA9IGNoaWxkcmVuLmZpcnN0KClcXG4gICAgICAgICQoc3RydWN0dXJlKS5hcHBlbmQodGhpcylcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XFxuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyksIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpLFxcbiAgICAgICAgICAgIGRvbSAgPSBmdW5jID8gc3RydWN0dXJlLmNhbGwodGhpcywgaW5kZXgpIDogc3RydWN0dXJlXFxuICAgICAgICBjb250ZW50cy5sZW5ndGggPyBjb250ZW50cy53cmFwQWxsKGRvbSkgOiBzZWxmLmFwcGVuZChkb20pXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgdW53cmFwOiBmdW5jdGlvbigpe1xcbiAgICAgIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgICAgJCh0aGlzKS5yZXBsYWNlV2l0aCgkKHRoaXMpLmNoaWxkcmVuKCkpXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBjbG9uZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpIH0pXFxuICAgIH0sXFxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKVxcbiAgICB9LFxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uKHNldHRpbmcpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAgIHZhciBlbCA9ICQodGhpcylcXG4gICAgICAgIDsoc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZWwuY3NzKFxcXCJkaXNwbGF5XFxcIikgPT0gXFxcIm5vbmVcXFwiIDogc2V0dGluZykgPyBlbC5zaG93KCkgOiBlbC5oaWRlKClcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBwcmV2OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcXG4gICAgbmV4dDogZnVuY3Rpb24oc2VsZWN0b3IpeyByZXR1cm4gJCh0aGlzLnBsdWNrKCduZXh0RWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcXG4gICAgaHRtbDogZnVuY3Rpb24oaHRtbCl7XFxuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICB2YXIgb3JpZ2luSHRtbCA9IHRoaXMuaW5uZXJIVE1MXFxuICAgICAgICAgICQodGhpcykuZW1wdHkoKS5hcHBlbmQoIGZ1bmNBcmcodGhpcywgaHRtbCwgaWR4LCBvcmlnaW5IdG1sKSApXFxuICAgICAgICB9KSA6XFxuICAgICAgICAoMCBpbiB0aGlzID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsKVxcbiAgICB9LFxcbiAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0KXtcXG4gICAgICByZXR1cm4gMCBpbiBhcmd1bWVudHMgP1xcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIHZhciBuZXdUZXh0ID0gZnVuY0FyZyh0aGlzLCB0ZXh0LCBpZHgsIHRoaXMudGV4dENvbnRlbnQpXFxuICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBuZXdUZXh0ID09IG51bGwgPyAnJyA6ICcnK25ld1RleHRcXG4gICAgICAgIH0pIDpcXG4gICAgICAgICgwIGluIHRoaXMgPyB0aGlzLnBsdWNrKCd0ZXh0Q29udGVudCcpLmpvaW4oXFxcIlxcXCIpIDogbnVsbClcXG4gICAgfSxcXG4gICAgYXR0cjogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xcbiAgICAgIHZhciByZXN1bHRcXG4gICAgICByZXR1cm4gKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmICEoMSBpbiBhcmd1bWVudHMpKSA/XFxuICAgICAgICAoMCBpbiB0aGlzICYmIHRoaXNbMF0ubm9kZVR5cGUgPT0gMSAmJiAocmVzdWx0ID0gdGhpc1swXS5nZXRBdHRyaWJ1dGUobmFtZSkpICE9IG51bGwgPyByZXN1bHQgOiB1bmRlZmluZWQpIDpcXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuXFxuICAgICAgICAgIGlmIChpc09iamVjdChuYW1lKSkgZm9yIChrZXkgaW4gbmFtZSkgc2V0QXR0cmlidXRlKHRoaXMsIGtleSwgbmFtZVtrZXldKVxcbiAgICAgICAgICBlbHNlIHNldEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpKSlcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xcbiAgICAgICAgc2V0QXR0cmlidXRlKHRoaXMsIGF0dHJpYnV0ZSlcXG4gICAgICB9LCB0aGlzKX0pXFxuICAgIH0sXFxuICAgIHByb3A6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcXG4gICAgICBuYW1lID0gcHJvcE1hcFtuYW1lXSB8fCBuYW1lXFxuICAgICAgcmV0dXJuICgxIGluIGFyZ3VtZW50cykgP1xcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIHRoaXNbbmFtZV0pXFxuICAgICAgICB9KSA6XFxuICAgICAgICAodGhpc1swXSAmJiB0aGlzWzBdW25hbWVdKVxcbiAgICB9LFxcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICBuYW1lID0gcHJvcE1hcFtuYW1lXSB8fCBuYW1lXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyBkZWxldGUgdGhpc1tuYW1lXSB9KVxcbiAgICB9LFxcbiAgICBkYXRhOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XFxuICAgICAgdmFyIGF0dHJOYW1lID0gJ2RhdGEtJyArIG5hbWUucmVwbGFjZShjYXBpdGFsUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXFxuXFxuICAgICAgdmFyIGRhdGEgPSAoMSBpbiBhcmd1bWVudHMpID9cXG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSwgdmFsdWUpIDpcXG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSlcXG5cXG4gICAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRlc2VyaWFsaXplVmFsdWUoZGF0YSkgOiB1bmRlZmluZWRcXG4gICAgfSxcXG4gICAgdmFsOiBmdW5jdGlvbih2YWx1ZSl7XFxuICAgICAgaWYgKDAgaW4gYXJndW1lbnRzKSB7XFxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICB0aGlzLnZhbHVlID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLnZhbHVlKVxcbiAgICAgICAgfSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgKHRoaXNbMF0ubXVsdGlwbGUgP1xcbiAgICAgICAgICAgJCh0aGlzWzBdKS5maW5kKCdvcHRpb24nKS5maWx0ZXIoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgfSkucGx1Y2soJ3ZhbHVlJykgOlxcbiAgICAgICAgICAgdGhpc1swXS52YWx1ZSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIG9mZnNldDogZnVuY3Rpb24oY29vcmRpbmF0ZXMpe1xcbiAgICAgIGlmIChjb29yZGluYXRlcykgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XFxuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgIGNvb3JkcyA9IGZ1bmNBcmcodGhpcywgY29vcmRpbmF0ZXMsIGluZGV4LCAkdGhpcy5vZmZzZXQoKSksXFxuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gJHRoaXMub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCksXFxuICAgICAgICAgICAgcHJvcHMgPSB7XFxuICAgICAgICAgICAgICB0b3A6ICBjb29yZHMudG9wICAtIHBhcmVudE9mZnNldC50b3AsXFxuICAgICAgICAgICAgICBsZWZ0OiBjb29yZHMubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCR0aGlzLmNzcygncG9zaXRpb24nKSA9PSAnc3RhdGljJykgcHJvcHNbJ3Bvc2l0aW9uJ10gPSAncmVsYXRpdmUnXFxuICAgICAgICAkdGhpcy5jc3MocHJvcHMpXFxuICAgICAgfSlcXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gbnVsbFxcbiAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IHRoaXNbMF0gJiYgISQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzWzBdKSlcXG4gICAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiAwfVxcbiAgICAgIHZhciBvYmogPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGxlZnQ6IG9iai5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxcbiAgICAgICAgdG9wOiBvYmoudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQob2JqLndpZHRoKSxcXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChvYmouaGVpZ2h0KVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY3NzOiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpe1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzWzBdXFxuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXFxuICAgICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlW2NhbWVsaXplKHByb3BlcnR5KV0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJykuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSlcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShwcm9wZXJ0eSkpIHtcXG4gICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cXG4gICAgICAgICAgdmFyIHByb3BzID0ge31cXG4gICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKVxcbiAgICAgICAgICAkLmVhY2gocHJvcGVydHksIGZ1bmN0aW9uKF8sIHByb3Ape1xcbiAgICAgICAgICAgIHByb3BzW3Byb3BdID0gKGVsZW1lbnQuc3R5bGVbY2FtZWxpemUocHJvcCldIHx8IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKSlcXG4gICAgICAgICAgfSlcXG4gICAgICAgICAgcmV0dXJuIHByb3BzXFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjc3MgPSAnJ1xcbiAgICAgIGlmICh0eXBlKHByb3BlcnR5KSA9PSAnc3RyaW5nJykge1xcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMClcXG4gICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoZGFzaGVyaXplKHByb3BlcnR5KSkgfSlcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgY3NzID0gZGFzaGVyaXplKHByb3BlcnR5KSArIFxcXCI6XFxcIiArIG1heWJlQWRkUHgocHJvcGVydHksIHZhbHVlKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBmb3IgKGtleSBpbiBwcm9wZXJ0eSlcXG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eVtrZXldICYmIHByb3BlcnR5W2tleV0gIT09IDApXFxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoZGFzaGVyaXplKGtleSkpIH0pXFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICBjc3MgKz0gZGFzaGVyaXplKGtleSkgKyAnOicgKyBtYXliZUFkZFB4KGtleSwgcHJvcGVydHlba2V5XSkgKyAnOydcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgY3NzIH0pXFxuICAgIH0sXFxuICAgIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KXtcXG4gICAgICByZXR1cm4gZWxlbWVudCA/IHRoaXMuaW5kZXhPZigkKGVsZW1lbnQpWzBdKSA6IHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5pbmRleE9mKHRoaXNbMF0pXFxuICAgIH0sXFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZVxcbiAgICAgIHJldHVybiBlbXB0eUFycmF5LnNvbWUuY2FsbCh0aGlzLCBmdW5jdGlvbihlbCl7XFxuICAgICAgICByZXR1cm4gdGhpcy50ZXN0KGNsYXNzTmFtZShlbCkpXFxuICAgICAgfSwgY2xhc3NSRShuYW1lKSlcXG4gICAgfSxcXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIHRoaXNcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXFxuICAgICAgICBjbGFzc0xpc3QgPSBbXVxcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzTmFtZSh0aGlzKSwgbmV3TmFtZSA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbHMpXFxuICAgICAgICBuZXdOYW1lLnNwbGl0KC9cXFxccysvZykuZm9yRWFjaChmdW5jdGlvbihrbGFzcyl7XFxuICAgICAgICAgIGlmICghJCh0aGlzKS5oYXNDbGFzcyhrbGFzcykpIGNsYXNzTGlzdC5wdXNoKGtsYXNzKVxcbiAgICAgICAgfSwgdGhpcylcXG4gICAgICAgIGNsYXNzTGlzdC5sZW5ndGggJiYgY2xhc3NOYW1lKHRoaXMsIGNscyArIChjbHMgPyBcXFwiIFxcXCIgOiBcXFwiXFxcIikgKyBjbGFzc0xpc3Quam9pbihcXFwiIFxcXCIpKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXFxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2xhc3NOYW1lKHRoaXMsICcnKVxcbiAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NOYW1lKHRoaXMpXFxuICAgICAgICBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xhc3NMaXN0KS5zcGxpdCgvXFxcXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xcbiAgICAgICAgICBjbGFzc0xpc3QgPSBjbGFzc0xpc3QucmVwbGFjZShjbGFzc1JFKGtsYXNzKSwgXFxcIiBcXFwiKVxcbiAgICAgICAgfSlcXG4gICAgICAgIGNsYXNzTmFtZSh0aGlzLCBjbGFzc0xpc3QudHJpbSgpKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihuYW1lLCB3aGVuKXtcXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiB0aGlzXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgbmFtZXMgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xhc3NOYW1lKHRoaXMpKVxcbiAgICAgICAgbmFtZXMuc3BsaXQoL1xcXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uKGtsYXNzKXtcXG4gICAgICAgICAgKHdoZW4gPT09IHVuZGVmaW5lZCA/ICEkdGhpcy5oYXNDbGFzcyhrbGFzcykgOiB3aGVuKSA/XFxuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Moa2xhc3MpIDogJHRoaXMucmVtb3ZlQ2xhc3Moa2xhc3MpXFxuICAgICAgICB9KVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHNjcm9sbFRvcDogZnVuY3Rpb24odmFsdWUpe1xcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxcbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdXFxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBoYXNTY3JvbGxUb3AgPyB0aGlzWzBdLnNjcm9sbFRvcCA6IHRoaXNbMF0ucGFnZVlPZmZzZXRcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGhhc1Njcm9sbFRvcCA/XFxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlIH0gOlxcbiAgICAgICAgZnVuY3Rpb24oKXsgdGhpcy5zY3JvbGxUbyh0aGlzLnNjcm9sbFgsIHZhbHVlKSB9KVxcbiAgICB9LFxcbiAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbih2YWx1ZSl7XFxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuXFxuICAgICAgdmFyIGhhc1Njcm9sbExlZnQgPSAnc2Nyb2xsTGVmdCcgaW4gdGhpc1swXVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXRcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGhhc1Njcm9sbExlZnQgP1xcbiAgICAgICAgZnVuY3Rpb24oKXsgdGhpcy5zY3JvbGxMZWZ0ID0gdmFsdWUgfSA6XFxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpIH0pXFxuICAgIH0sXFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cXG5cXG4gICAgICB2YXIgZWxlbSA9IHRoaXNbMF0sXFxuICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKSxcXG4gICAgICAgIC8vIEdldCBjb3JyZWN0IG9mZnNldHNcXG4gICAgICAgIG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXFxuICAgICAgICBwYXJlbnRPZmZzZXQgPSByb290Tm9kZVJFLnRlc3Qob2Zmc2V0UGFyZW50WzBdLm5vZGVOYW1lKSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiBvZmZzZXRQYXJlbnQub2Zmc2V0KClcXG5cXG4gICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcXG4gICAgICAvLyBub3RlOiB3aGVuIGFuIGVsZW1lbnQgaGFzIG1hcmdpbjogYXV0byB0aGUgb2Zmc2V0TGVmdCBhbmQgbWFyZ2luTGVmdFxcbiAgICAgIC8vIGFyZSB0aGUgc2FtZSBpbiBTYWZhcmkgY2F1c2luZyBvZmZzZXQubGVmdCB0byBpbmNvcnJlY3RseSBiZSAwXFxuICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi10b3AnKSApIHx8IDBcXG4gICAgICBvZmZzZXQubGVmdCAtPSBwYXJzZUZsb2F0KCAkKGVsZW0pLmNzcygnbWFyZ2luLWxlZnQnKSApIHx8IDBcXG5cXG4gICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcXG4gICAgICBwYXJlbnRPZmZzZXQudG9wICArPSBwYXJzZUZsb2F0KCAkKG9mZnNldFBhcmVudFswXSkuY3NzKCdib3JkZXItdG9wLXdpZHRoJykgKSB8fCAwXFxuICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdCggJChvZmZzZXRQYXJlbnRbMF0pLmNzcygnYm9yZGVyLWxlZnQtd2lkdGgnKSApIHx8IDBcXG5cXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgdHdvIG9mZnNldHNcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdFxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtcXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5XFxuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFyb290Tm9kZVJFLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiAkKHBhcmVudCkuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09IFxcXCJzdGF0aWNcXFwiKVxcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50XFxuICAgICAgICByZXR1cm4gcGFyZW50XFxuICAgICAgfSlcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gZm9yIG5vd1xcbiAgJC5mbi5kZXRhY2ggPSAkLmZuLnJlbW92ZVxcblxcbiAgLy8gR2VuZXJhdGUgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGZ1bmN0aW9uc1xcbiAgO1snd2lkdGgnLCAnaGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbihkaW1lbnNpb24pe1xcbiAgICB2YXIgZGltZW5zaW9uUHJvcGVydHkgPVxcbiAgICAgIGRpbWVuc2lvbi5yZXBsYWNlKC8uLywgZnVuY3Rpb24obSl7IHJldHVybiBtWzBdLnRvVXBwZXJDYXNlKCkgfSlcXG5cXG4gICAgJC5mbltkaW1lbnNpb25dID0gZnVuY3Rpb24odmFsdWUpe1xcbiAgICAgIHZhciBvZmZzZXQsIGVsID0gdGhpc1swXVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaXNXaW5kb3coZWwpID8gZWxbJ2lubmVyJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XFxuICAgICAgICBpc0RvY3VtZW50KGVsKSA/IGVsLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XFxuICAgICAgICAob2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSkgJiYgb2Zmc2V0W2RpbWVuc2lvbl1cXG4gICAgICBlbHNlIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgIGVsID0gJCh0aGlzKVxcbiAgICAgICAgZWwuY3NzKGRpbWVuc2lvbiwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCBlbFtkaW1lbnNpb25dKCkpKVxcbiAgICAgIH0pXFxuICAgIH1cXG4gIH0pXFxuXFxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgZnVuKSB7XFxuICAgIGZ1bihub2RlKVxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxcbiAgICAgIHRyYXZlcnNlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGZ1bilcXG4gIH1cXG5cXG4gIC8vIEdlbmVyYXRlIHRoZSBgYWZ0ZXJgLCBgcHJlcGVuZGAsIGBiZWZvcmVgLCBgYXBwZW5kYCxcXG4gIC8vIGBpbnNlcnRBZnRlcmAsIGBpbnNlcnRCZWZvcmVgLCBgYXBwZW5kVG9gLCBhbmQgYHByZXBlbmRUb2AgbWV0aG9kcy5cXG4gIGFkamFjZW5jeU9wZXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKG9wZXJhdG9yLCBvcGVyYXRvckluZGV4KSB7XFxuICAgIHZhciBpbnNpZGUgPSBvcGVyYXRvckluZGV4ICUgMiAvLz0+IHByZXBlbmQsIGFwcGVuZFxcblxcbiAgICAkLmZuW29wZXJhdG9yXSA9IGZ1bmN0aW9uKCl7XFxuICAgICAgLy8gYXJndW1lbnRzIGNhbiBiZSBub2RlcywgYXJyYXlzIG9mIG5vZGVzLCBaZXB0byBvYmplY3RzIGFuZCBIVE1MIHN0cmluZ3NcXG4gICAgICB2YXIgYXJnVHlwZSwgbm9kZXMgPSAkLm1hcChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXVxcbiAgICAgICAgICAgIGFyZ1R5cGUgPSB0eXBlKGFyZylcXG4gICAgICAgICAgICBpZiAoYXJnVHlwZSA9PSBcXFwiYXJyYXlcXFwiKSB7XFxuICAgICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbihlbCkge1xcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGFyci5wdXNoKGVsKVxcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkLnplcHRvLmlzWihlbCkpIHJldHVybiBhcnIgPSBhcnIuY29uY2F0KGVsLmdldCgpKVxcbiAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KHplcHRvLmZyYWdtZW50KGVsKSlcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICByZXR1cm4gYXJyXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFxcXCJvYmplY3RcXFwiIHx8IGFyZyA9PSBudWxsID9cXG4gICAgICAgICAgICAgIGFyZyA6IHplcHRvLmZyYWdtZW50KGFyZylcXG4gICAgICAgICAgfSksXFxuICAgICAgICAgIHBhcmVudCwgY29weUJ5Q2xvbmUgPSB0aGlzLmxlbmd0aCA+IDFcXG4gICAgICBpZiAobm9kZXMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXNcXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKF8sIHRhcmdldCl7XFxuICAgICAgICBwYXJlbnQgPSBpbnNpZGUgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZVxcblxcbiAgICAgICAgLy8gY29udmVydCBhbGwgbWV0aG9kcyB0byBhIFxcXCJiZWZvcmVcXFwiIG9wZXJhdGlvblxcbiAgICAgICAgdGFyZ2V0ID0gb3BlcmF0b3JJbmRleCA9PSAwID8gdGFyZ2V0Lm5leHRTaWJsaW5nIDpcXG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMSA/IHRhcmdldC5maXJzdENoaWxkIDpcXG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMiA/IHRhcmdldCA6XFxuICAgICAgICAgICAgICAgICBudWxsXFxuXFxuICAgICAgICB2YXIgcGFyZW50SW5Eb2N1bWVudCA9ICQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBwYXJlbnQpXFxuXFxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xcbiAgICAgICAgICBpZiAoY29weUJ5Q2xvbmUpIG5vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKVxcbiAgICAgICAgICBlbHNlIGlmICghcGFyZW50KSByZXR1cm4gJChub2RlKS5yZW1vdmUoKVxcblxcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldClcXG4gICAgICAgICAgaWYgKHBhcmVudEluRG9jdW1lbnQpIHRyYXZlcnNlTm9kZShub2RlLCBmdW5jdGlvbihlbCl7XFxuICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lICE9IG51bGwgJiYgZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcgJiZcXG4gICAgICAgICAgICAgICAoIWVsLnR5cGUgfHwgZWwudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpICYmICFlbC5zcmMpe1xcbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGVsLm93bmVyRG9jdW1lbnQgPyBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93XFxuICAgICAgICAgICAgICB0YXJnZXRbJ2V2YWwnXS5jYWxsKHRhcmdldCwgZWwuaW5uZXJIVE1MKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgICAgfSlcXG4gICAgfVxcblxcbiAgICAvLyBhZnRlciAgICA9PiBpbnNlcnRBZnRlclxcbiAgICAvLyBwcmVwZW5kICA9PiBwcmVwZW5kVG9cXG4gICAgLy8gYmVmb3JlICAgPT4gaW5zZXJ0QmVmb3JlXFxuICAgIC8vIGFwcGVuZCAgID0+IGFwcGVuZFRvXFxuICAgICQuZm5baW5zaWRlID8gb3BlcmF0b3IrJ1RvJyA6ICdpbnNlcnQnKyhvcGVyYXRvckluZGV4ID8gJ0JlZm9yZScgOiAnQWZ0ZXInKV0gPSBmdW5jdGlvbihodG1sKXtcXG4gICAgICAkKGh0bWwpW29wZXJhdG9yXSh0aGlzKVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH1cXG4gIH0pXFxuXFxuICB6ZXB0by5aLnByb3RvdHlwZSA9IFoucHJvdG90eXBlID0gJC5mblxcblxcbiAgLy8gRXhwb3J0IGludGVybmFsIEFQSSBmdW5jdGlvbnMgaW4gdGhlIGAkLnplcHRvYCBuYW1lc3BhY2VcXG4gIHplcHRvLnVuaXEgPSB1bmlxXFxuICB6ZXB0by5kZXNlcmlhbGl6ZVZhbHVlID0gZGVzZXJpYWxpemVWYWx1ZVxcbiAgJC56ZXB0byA9IHplcHRvXFxuXFxuICByZXR1cm4gJFxcbn0pKClcXG5cXG53aW5kb3cuWmVwdG8gPSBaZXB0b1xcbndpbmRvdy4kID09PSB1bmRlZmluZWQgJiYgKHdpbmRvdy4kID0gWmVwdG8pXFxuXFxuOyhmdW5jdGlvbigkKXtcXG4gIHZhciBfemlkID0gMSwgdW5kZWZpbmVkLFxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxcbiAgICAgIGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb24sXFxuICAgICAgaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopeyByZXR1cm4gdHlwZW9mIG9iaiA9PSAnc3RyaW5nJyB9LFxcbiAgICAgIGhhbmRsZXJzID0ge30sXFxuICAgICAgc3BlY2lhbEV2ZW50cz17fSxcXG4gICAgICBmb2N1c2luU3VwcG9ydGVkID0gJ29uZm9jdXNpbicgaW4gd2luZG93LFxcbiAgICAgIGZvY3VzID0geyBmb2N1czogJ2ZvY3VzaW4nLCBibHVyOiAnZm9jdXNvdXQnIH0sXFxuICAgICAgaG92ZXIgPSB7IG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLCBtb3VzZWxlYXZlOiAnbW91c2VvdXQnIH1cXG5cXG4gIHNwZWNpYWxFdmVudHMuY2xpY2sgPSBzcGVjaWFsRXZlbnRzLm1vdXNlZG93biA9IHNwZWNpYWxFdmVudHMubW91c2V1cCA9IHNwZWNpYWxFdmVudHMubW91c2Vtb3ZlID0gJ01vdXNlRXZlbnRzJ1xcblxcbiAgZnVuY3Rpb24gemlkKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIGVsZW1lbnQuX3ppZCB8fCAoZWxlbWVudC5femlkID0gX3ppZCsrKVxcbiAgfVxcbiAgZnVuY3Rpb24gZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LCBmbiwgc2VsZWN0b3IpIHtcXG4gICAgZXZlbnQgPSBwYXJzZShldmVudClcXG4gICAgaWYgKGV2ZW50Lm5zKSB2YXIgbWF0Y2hlciA9IG1hdGNoZXJGb3IoZXZlbnQubnMpXFxuICAgIHJldHVybiAoaGFuZGxlcnNbemlkKGVsZW1lbnQpXSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGhhbmRsZXIpIHtcXG4gICAgICByZXR1cm4gaGFuZGxlclxcbiAgICAgICAgJiYgKCFldmVudC5lICB8fCBoYW5kbGVyLmUgPT0gZXZlbnQuZSlcXG4gICAgICAgICYmICghZXZlbnQubnMgfHwgbWF0Y2hlci50ZXN0KGhhbmRsZXIubnMpKVxcbiAgICAgICAgJiYgKCFmbiAgICAgICB8fCB6aWQoaGFuZGxlci5mbikgPT09IHppZChmbikpXFxuICAgICAgICAmJiAoIXNlbGVjdG9yIHx8IGhhbmRsZXIuc2VsID09IHNlbGVjdG9yKVxcbiAgICB9KVxcbiAgfVxcbiAgZnVuY3Rpb24gcGFyc2UoZXZlbnQpIHtcXG4gICAgdmFyIHBhcnRzID0gKCcnICsgZXZlbnQpLnNwbGl0KCcuJylcXG4gICAgcmV0dXJuIHtlOiBwYXJ0c1swXSwgbnM6IHBhcnRzLnNsaWNlKDEpLnNvcnQoKS5qb2luKCcgJyl9XFxuICB9XFxuICBmdW5jdGlvbiBtYXRjaGVyRm9yKG5zKSB7XFxuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefCApJyArIG5zLnJlcGxhY2UoJyAnLCAnIC4qID8nKSArICcoPzogfCQpJylcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlU2V0dGluZykge1xcbiAgICByZXR1cm4gaGFuZGxlci5kZWwgJiZcXG4gICAgICAoIWZvY3VzaW5TdXBwb3J0ZWQgJiYgKGhhbmRsZXIuZSBpbiBmb2N1cykpIHx8XFxuICAgICAgISFjYXB0dXJlU2V0dGluZ1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVhbEV2ZW50KHR5cGUpIHtcXG4gICAgcmV0dXJuIGhvdmVyW3R5cGVdIHx8IChmb2N1c2luU3VwcG9ydGVkICYmIGZvY3VzW3R5cGVdKSB8fCB0eXBlXFxuICB9XFxuXFxuICBmdW5jdGlvbiBhZGQoZWxlbWVudCwgZXZlbnRzLCBmbiwgZGF0YSwgc2VsZWN0b3IsIGRlbGVnYXRvciwgY2FwdHVyZSl7XFxuICAgIHZhciBpZCA9IHppZChlbGVtZW50KSwgc2V0ID0gKGhhbmRsZXJzW2lkXSB8fCAoaGFuZGxlcnNbaWRdID0gW10pKVxcbiAgICBldmVudHMuc3BsaXQoL1xcXFxzLykuZm9yRWFjaChmdW5jdGlvbihldmVudCl7XFxuICAgICAgaWYgKGV2ZW50ID09ICdyZWFkeScpIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShmbilcXG4gICAgICB2YXIgaGFuZGxlciAgID0gcGFyc2UoZXZlbnQpXFxuICAgICAgaGFuZGxlci5mbiAgICA9IGZuXFxuICAgICAgaGFuZGxlci5zZWwgICA9IHNlbGVjdG9yXFxuICAgICAgLy8gZW11bGF0ZSBtb3VzZWVudGVyLCBtb3VzZWxlYXZlXFxuICAgICAgaWYgKGhhbmRsZXIuZSBpbiBob3ZlcikgZm4gPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0XFxuICAgICAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgISQuY29udGFpbnModGhpcywgcmVsYXRlZCkpKVxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlci5mbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxuICAgICAgfVxcbiAgICAgIGhhbmRsZXIuZGVsICAgPSBkZWxlZ2F0b3JcXG4gICAgICB2YXIgY2FsbGJhY2sgID0gZGVsZWdhdG9yIHx8IGZuXFxuICAgICAgaGFuZGxlci5wcm94eSA9IGZ1bmN0aW9uKGUpe1xcbiAgICAgICAgZSA9IGNvbXBhdGlibGUoZSlcXG4gICAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVyblxcbiAgICAgICAgZS5kYXRhID0gZGF0YVxcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KGVsZW1lbnQsIGUuX2FyZ3MgPT0gdW5kZWZpbmVkID8gW2VdIDogW2VdLmNvbmNhdChlLl9hcmdzKSlcXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKClcXG4gICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICB9XFxuICAgICAgaGFuZGxlci5pID0gc2V0Lmxlbmd0aFxcbiAgICAgIHNldC5wdXNoKGhhbmRsZXIpXFxuICAgICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KVxcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHJlYWxFdmVudChoYW5kbGVyLmUpLCBoYW5kbGVyLnByb3h5LCBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZSkpXFxuICAgIH0pXFxuICB9XFxuICBmdW5jdGlvbiByZW1vdmUoZWxlbWVudCwgZXZlbnRzLCBmbiwgc2VsZWN0b3IsIGNhcHR1cmUpe1xcbiAgICB2YXIgaWQgPSB6aWQoZWxlbWVudClcXG4gICAgOyhldmVudHMgfHwgJycpLnNwbGl0KC9cXFxccy8pLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xcbiAgICAgIGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudCwgZm4sIHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpe1xcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2lkXVtoYW5kbGVyLmldXFxuICAgICAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KVxcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHJlYWxFdmVudChoYW5kbGVyLmUpLCBoYW5kbGVyLnByb3h5LCBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZSkpXFxuICAgICAgfSlcXG4gICAgfSlcXG4gIH1cXG5cXG4gICQuZXZlbnQgPSB7IGFkZDogYWRkLCByZW1vdmU6IHJlbW92ZSB9XFxuXFxuICAkLnByb3h5ID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcXG4gICAgdmFyIGFyZ3MgPSAoMiBpbiBhcmd1bWVudHMpICYmIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcXG4gICAgICB2YXIgcHJveHlGbiA9IGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cykgfVxcbiAgICAgIHByb3h5Rm4uX3ppZCA9IHppZChmbilcXG4gICAgICByZXR1cm4gcHJveHlGblxcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbnRleHQpKSB7XFxuICAgICAgaWYgKGFyZ3MpIHtcXG4gICAgICAgIGFyZ3MudW5zaGlmdChmbltjb250ZXh0XSwgZm4pXFxuICAgICAgICByZXR1cm4gJC5wcm94eS5hcHBseShudWxsLCBhcmdzKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gJC5wcm94eShmbltjb250ZXh0XSwgZm4pXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcImV4cGVjdGVkIGZ1bmN0aW9uXFxcIilcXG4gICAgfVxcbiAgfVxcblxcbiAgJC5mbi5iaW5kID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKVxcbiAgfVxcbiAgJC5mbi51bmJpbmQgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGNhbGxiYWNrKVxcbiAgfVxcbiAgJC5mbi5vbmUgPSBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgMSlcXG4gIH1cXG5cXG4gIHZhciByZXR1cm5UcnVlID0gZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZX0sXFxuICAgICAgcmV0dXJuRmFsc2UgPSBmdW5jdGlvbigpe3JldHVybiBmYWxzZX0sXFxuICAgICAgaWdub3JlUHJvcGVydGllcyA9IC9eKFtBLVpdfHJldHVyblZhbHVlJHxsYXllcltYWV0kfHdlYmtpdE1vdmVtZW50W1hZXSQpLyxcXG4gICAgICBldmVudE1ldGhvZHMgPSB7XFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogJ2lzRGVmYXVsdFByZXZlbnRlZCcsXFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ICdpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCcsXFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCdcXG4gICAgICB9XFxuXFxuICBmdW5jdGlvbiBjb21wYXRpYmxlKGV2ZW50LCBzb3VyY2UpIHtcXG4gICAgaWYgKHNvdXJjZSB8fCAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgc291cmNlIHx8IChzb3VyY2UgPSBldmVudClcXG5cXG4gICAgICAkLmVhY2goZXZlbnRNZXRob2RzLCBmdW5jdGlvbihuYW1lLCBwcmVkaWNhdGUpIHtcXG4gICAgICAgIHZhciBzb3VyY2VNZXRob2QgPSBzb3VyY2VbbmFtZV1cXG4gICAgICAgIGV2ZW50W25hbWVdID0gZnVuY3Rpb24oKXtcXG4gICAgICAgICAgdGhpc1twcmVkaWNhdGVdID0gcmV0dXJuVHJ1ZVxcbiAgICAgICAgICByZXR1cm4gc291cmNlTWV0aG9kICYmIHNvdXJjZU1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cylcXG4gICAgICAgIH1cXG4gICAgICAgIGV2ZW50W3ByZWRpY2F0ZV0gPSByZXR1cm5GYWxzZVxcbiAgICAgIH0pXFxuXFxuICAgICAgZXZlbnQudGltZVN0YW1wIHx8IChldmVudC50aW1lU3RhbXAgPSBEYXRlLm5vdygpKVxcblxcbiAgICAgIGlmIChzb3VyY2UuZGVmYXVsdFByZXZlbnRlZCAhPT0gdW5kZWZpbmVkID8gc291cmNlLmRlZmF1bHRQcmV2ZW50ZWQgOlxcbiAgICAgICAgICAncmV0dXJuVmFsdWUnIGluIHNvdXJjZSA/IHNvdXJjZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgOlxcbiAgICAgICAgICBzb3VyY2UuZ2V0UHJldmVudERlZmF1bHQgJiYgc291cmNlLmdldFByZXZlbnREZWZhdWx0KCkpXFxuICAgICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlXFxuICAgIH1cXG4gICAgcmV0dXJuIGV2ZW50XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVQcm94eShldmVudCkge1xcbiAgICB2YXIga2V5LCBwcm94eSA9IHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfVxcbiAgICBmb3IgKGtleSBpbiBldmVudClcXG4gICAgICBpZiAoIWlnbm9yZVByb3BlcnRpZXMudGVzdChrZXkpICYmIGV2ZW50W2tleV0gIT09IHVuZGVmaW5lZCkgcHJveHlba2V5XSA9IGV2ZW50W2tleV1cXG5cXG4gICAgcmV0dXJuIGNvbXBhdGlibGUocHJveHksIGV2ZW50KVxcbiAgfVxcblxcbiAgJC5mbi5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxcbiAgfVxcbiAgJC5mbi51bmRlbGVnYXRlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjayl7XFxuICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxcbiAgfVxcblxcbiAgJC5mbi5saXZlID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcXG4gICAgJChkb2N1bWVudC5ib2R5KS5kZWxlZ2F0ZSh0aGlzLnNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spXFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuICAkLmZuLmRpZSA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjayl7XFxuICAgICQoZG9jdW1lbnQuYm9keSkudW5kZWxlZ2F0ZSh0aGlzLnNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spXFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxuICAkLmZuLm9uID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgb25lKXtcXG4gICAgdmFyIGF1dG9SZW1vdmUsIGRlbGVnYXRvciwgJHRoaXMgPSB0aGlzXFxuICAgIGlmIChldmVudCAmJiAhaXNTdHJpbmcoZXZlbnQpKSB7XFxuICAgICAgJC5lYWNoKGV2ZW50LCBmdW5jdGlvbih0eXBlLCBmbil7XFxuICAgICAgICAkdGhpcy5vbih0eXBlLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSlcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiAkdGhpc1xcbiAgICB9XFxuXFxuICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjayAhPT0gZmFsc2UpXFxuICAgICAgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gc2VsZWN0b3IsIHNlbGVjdG9yID0gdW5kZWZpbmVkXFxuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IGZhbHNlKVxcbiAgICAgIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IHVuZGVmaW5lZFxcblxcbiAgICBpZiAoY2FsbGJhY2sgPT09IGZhbHNlKSBjYWxsYmFjayA9IHJldHVybkZhbHNlXFxuXFxuICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKF8sIGVsZW1lbnQpe1xcbiAgICAgIGlmIChvbmUpIGF1dG9SZW1vdmUgPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIHJlbW92ZShlbGVtZW50LCBlLnR5cGUsIGNhbGxiYWNrKVxcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNlbGVjdG9yKSBkZWxlZ2F0b3IgPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIHZhciBldnQsIG1hdGNoID0gJChlLnRhcmdldCkuY2xvc2VzdChzZWxlY3RvciwgZWxlbWVudCkuZ2V0KDApXFxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2ggIT09IGVsZW1lbnQpIHtcXG4gICAgICAgICAgZXZ0ID0gJC5leHRlbmQoY3JlYXRlUHJveHkoZSksIHtjdXJyZW50VGFyZ2V0OiBtYXRjaCwgbGl2ZUZpcmVkOiBlbGVtZW50fSlcXG4gICAgICAgICAgcmV0dXJuIChhdXRvUmVtb3ZlIHx8IGNhbGxiYWNrKS5hcHBseShtYXRjaCwgW2V2dF0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpXFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGFkZChlbGVtZW50LCBldmVudCwgY2FsbGJhY2ssIGRhdGEsIHNlbGVjdG9yLCBkZWxlZ2F0b3IgfHwgYXV0b1JlbW92ZSlcXG4gICAgfSlcXG4gIH1cXG4gICQuZm4ub2ZmID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjayl7XFxuICAgIHZhciAkdGhpcyA9IHRoaXNcXG4gICAgaWYgKGV2ZW50ICYmICFpc1N0cmluZyhldmVudCkpIHtcXG4gICAgICAkLmVhY2goZXZlbnQsIGZ1bmN0aW9uKHR5cGUsIGZuKXtcXG4gICAgICAgICR0aGlzLm9mZih0eXBlLCBzZWxlY3RvciwgZm4pXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gJHRoaXNcXG4gICAgfVxcblxcbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2sgIT09IGZhbHNlKVxcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3IsIHNlbGVjdG9yID0gdW5kZWZpbmVkXFxuXFxuICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIGNhbGxiYWNrID0gcmV0dXJuRmFsc2VcXG5cXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICByZW1vdmUodGhpcywgZXZlbnQsIGNhbGxiYWNrLCBzZWxlY3RvcilcXG4gICAgfSlcXG4gIH1cXG5cXG4gICQuZm4udHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcXG4gICAgZXZlbnQgPSAoaXNTdHJpbmcoZXZlbnQpIHx8ICQuaXNQbGFpbk9iamVjdChldmVudCkpID8gJC5FdmVudChldmVudCkgOiBjb21wYXRpYmxlKGV2ZW50KVxcbiAgICBldmVudC5fYXJncyA9IGFyZ3NcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgIC8vIGhhbmRsZSBmb2N1cygpLCBibHVyKCkgYnkgY2FsbGluZyB0aGVtIGRpcmVjdGx5XFxuICAgICAgaWYgKGV2ZW50LnR5cGUgaW4gZm9jdXMgJiYgdHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gXFxcImZ1bmN0aW9uXFxcIikgdGhpc1tldmVudC50eXBlXSgpXFxuICAgICAgLy8gaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gbWlnaHQgbm90IGJlIERPTSBlbGVtZW50c1xcbiAgICAgIGVsc2UgaWYgKCdkaXNwYXRjaEV2ZW50JyBpbiB0aGlzKSB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXFxuICAgICAgZWxzZSAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKGV2ZW50LCBhcmdzKVxcbiAgICB9KVxcbiAgfVxcblxcbiAgLy8gdHJpZ2dlcnMgZXZlbnQgaGFuZGxlcnMgb24gY3VycmVudCBlbGVtZW50IGp1c3QgYXMgaWYgYW4gZXZlbnQgb2NjdXJyZWQsXFxuICAvLyBkb2Vzbid0IHRyaWdnZXIgYW4gYWN0dWFsIGV2ZW50LCBkb2Vzbid0IGJ1YmJsZVxcbiAgJC5mbi50cmlnZ2VySGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcXG4gICAgdmFyIGUsIHJlc3VsdFxcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWxlbWVudCl7XFxuICAgICAgZSA9IGNyZWF0ZVByb3h5KGlzU3RyaW5nKGV2ZW50KSA/ICQuRXZlbnQoZXZlbnQpIDogZXZlbnQpXFxuICAgICAgZS5fYXJncyA9IGFyZ3NcXG4gICAgICBlLnRhcmdldCA9IGVsZW1lbnRcXG4gICAgICAkLmVhY2goZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LnR5cGUgfHwgZXZlbnQpLCBmdW5jdGlvbihpLCBoYW5kbGVyKXtcXG4gICAgICAgIHJlc3VsdCA9IGhhbmRsZXIucHJveHkoZSlcXG4gICAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVybiBmYWxzZVxcbiAgICAgIH0pXFxuICAgIH0pXFxuICAgIHJldHVybiByZXN1bHRcXG4gIH1cXG5cXG4gIC8vIHNob3J0Y3V0IG1ldGhvZHMgZm9yIGAuYmluZChldmVudCwgZm4pYCBmb3IgZWFjaCBldmVudCB0eXBlXFxuICA7KCdmb2N1c2luIGZvY3Vzb3V0IGZvY3VzIGJsdXIgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayAnK1xcbiAgJ21vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlICcrXFxuICAnY2hhbmdlIHNlbGVjdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yJykuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XFxuICAgICQuZm5bZXZlbnRdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcXG4gICAgICByZXR1cm4gKDAgaW4gYXJndW1lbnRzKSA/XFxuICAgICAgICB0aGlzLmJpbmQoZXZlbnQsIGNhbGxiYWNrKSA6XFxuICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnQpXFxuICAgIH1cXG4gIH0pXFxuXFxuICAkLkV2ZW50ID0gZnVuY3Rpb24odHlwZSwgcHJvcHMpIHtcXG4gICAgaWYgKCFpc1N0cmluZyh0eXBlKSkgcHJvcHMgPSB0eXBlLCB0eXBlID0gcHJvcHMudHlwZVxcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChzcGVjaWFsRXZlbnRzW3R5cGVdIHx8ICdFdmVudHMnKSwgYnViYmxlcyA9IHRydWVcXG4gICAgaWYgKHByb3BzKSBmb3IgKHZhciBuYW1lIGluIHByb3BzKSAobmFtZSA9PSAnYnViYmxlcycpID8gKGJ1YmJsZXMgPSAhIXByb3BzW25hbWVdKSA6IChldmVudFtuYW1lXSA9IHByb3BzW25hbWVdKVxcbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgYnViYmxlcywgdHJ1ZSlcXG4gICAgcmV0dXJuIGNvbXBhdGlibGUoZXZlbnQpXFxuICB9XFxuXFxufSkoWmVwdG8pXFxuXFxuOyhmdW5jdGlvbigkKXtcXG4gIHZhciBqc29ucElEID0gK25ldyBEYXRlKCksXFxuICAgICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXFxuICAgICAga2V5LFxcbiAgICAgIG5hbWUsXFxuICAgICAgcnNjcmlwdCA9IC88c2NyaXB0XFxcXGJbXjxdKig/Oig/ITxcXFxcL3NjcmlwdD4pPFtePF0qKSo8XFxcXC9zY3JpcHQ+L2dpLFxcbiAgICAgIHNjcmlwdFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXFxcL2phdmFzY3JpcHQvaSxcXG4gICAgICB4bWxUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFxcXC94bWwvaSxcXG4gICAgICBqc29uVHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJyxcXG4gICAgICBodG1sVHlwZSA9ICd0ZXh0L2h0bWwnLFxcbiAgICAgIGJsYW5rUkUgPSAvXlxcXFxzKiQvLFxcbiAgICAgIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxcblxcbiAgb3JpZ2luQW5jaG9yLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxcblxcbiAgLy8gdHJpZ2dlciBhIGN1c3RvbSBldmVudCBhbmQgcmV0dXJuIGZhbHNlIGlmIGl0IHdhcyBjYW5jZWxsZWRcXG4gIGZ1bmN0aW9uIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XFxuICAgIHZhciBldmVudCA9ICQuRXZlbnQoZXZlbnROYW1lKVxcbiAgICAkKGNvbnRleHQpLnRyaWdnZXIoZXZlbnQsIGRhdGEpXFxuICAgIHJldHVybiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKClcXG4gIH1cXG5cXG4gIC8vIHRyaWdnZXIgYW4gQWpheCBcXFwiZ2xvYmFsXFxcIiBldmVudFxcbiAgZnVuY3Rpb24gdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XFxuICAgIGlmIChzZXR0aW5ncy5nbG9iYWwpIHJldHVybiB0cmlnZ2VyQW5kUmV0dXJuKGNvbnRleHQgfHwgZG9jdW1lbnQsIGV2ZW50TmFtZSwgZGF0YSlcXG4gIH1cXG5cXG4gIC8vIE51bWJlciBvZiBhY3RpdmUgQWpheCByZXF1ZXN0c1xcbiAgJC5hY3RpdmUgPSAwXFxuXFxuICBmdW5jdGlvbiBhamF4U3RhcnQoc2V0dGluZ3MpIHtcXG4gICAgaWYgKHNldHRpbmdzLmdsb2JhbCAmJiAkLmFjdGl2ZSsrID09PSAwKSB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBudWxsLCAnYWpheFN0YXJ0JylcXG4gIH1cXG4gIGZ1bmN0aW9uIGFqYXhTdG9wKHNldHRpbmdzKSB7XFxuICAgIGlmIChzZXR0aW5ncy5nbG9iYWwgJiYgISgtLSQuYWN0aXZlKSkgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgJ2FqYXhTdG9wJylcXG4gIH1cXG5cXG4gIC8vIHRyaWdnZXJzIGFuIGV4dHJhIGdsb2JhbCBldmVudCBcXFwiYWpheEJlZm9yZVNlbmRcXFwiIHRoYXQncyBsaWtlIFxcXCJhamF4U2VuZFxcXCIgYnV0IGNhbmNlbGFibGVcXG4gIGZ1bmN0aW9uIGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XFxuICAgIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kLmNhbGwoY29udGV4dCwgeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlIHx8XFxuICAgICAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheEJlZm9yZVNlbmQnLCBbeGhyLCBzZXR0aW5nc10pID09PSBmYWxzZSlcXG4gICAgICByZXR1cm4gZmFsc2VcXG5cXG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhTZW5kJywgW3hociwgc2V0dGluZ3NdKVxcbiAgfVxcbiAgZnVuY3Rpb24gYWpheFN1Y2Nlc3MoZGF0YSwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0LCBzdGF0dXMgPSAnc3VjY2VzcydcXG4gICAgc2V0dGluZ3Muc3VjY2Vzcy5jYWxsKGNvbnRleHQsIGRhdGEsIHN0YXR1cywgeGhyKVxcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlc29sdmVXaXRoKGNvbnRleHQsIFtkYXRhLCBzdGF0dXMsIHhocl0pXFxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4U3VjY2VzcycsIFt4aHIsIHNldHRpbmdzLCBkYXRhXSlcXG4gICAgYWpheENvbXBsZXRlKHN0YXR1cywgeGhyLCBzZXR0aW5ncylcXG4gIH1cXG4gIC8vIHR5cGU6IFxcXCJ0aW1lb3V0XFxcIiwgXFxcImVycm9yXFxcIiwgXFxcImFib3J0XFxcIiwgXFxcInBhcnNlcmVycm9yXFxcIlxcbiAgZnVuY3Rpb24gYWpheEVycm9yKGVycm9yLCB0eXBlLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZCkge1xcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcXG4gICAgc2V0dGluZ3MuZXJyb3IuY2FsbChjb250ZXh0LCB4aHIsIHR5cGUsIGVycm9yKVxcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlamVjdFdpdGgoY29udGV4dCwgW3hociwgdHlwZSwgZXJyb3JdKVxcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheEVycm9yJywgW3hociwgc2V0dGluZ3MsIGVycm9yIHx8IHR5cGVdKVxcbiAgICBhamF4Q29tcGxldGUodHlwZSwgeGhyLCBzZXR0aW5ncylcXG4gIH1cXG4gIC8vIHN0YXR1czogXFxcInN1Y2Nlc3NcXFwiLCBcXFwibm90bW9kaWZpZWRcXFwiLCBcXFwiZXJyb3JcXFwiLCBcXFwidGltZW91dFxcXCIsIFxcXCJhYm9ydFxcXCIsIFxcXCJwYXJzZXJlcnJvclxcXCJcXG4gIGZ1bmN0aW9uIGFqYXhDb21wbGV0ZShzdGF0dXMsIHhociwgc2V0dGluZ3MpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XFxuICAgIHNldHRpbmdzLmNvbXBsZXRlLmNhbGwoY29udGV4dCwgeGhyLCBzdGF0dXMpXFxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4Q29tcGxldGUnLCBbeGhyLCBzZXR0aW5nc10pXFxuICAgIGFqYXhTdG9wKHNldHRpbmdzKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWpheERhdGFGaWx0ZXIoZGF0YSwgdHlwZSwgc2V0dGluZ3MpIHtcXG4gICAgaWYgKHNldHRpbmdzLmRhdGFGaWx0ZXIgPT0gZW1wdHkpIHJldHVybiBkYXRhXFxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxcbiAgICByZXR1cm4gc2V0dGluZ3MuZGF0YUZpbHRlci5jYWxsKGNvbnRleHQsIGRhdGEsIHR5cGUpXFxuICB9XFxuXFxuICAvLyBFbXB0eSBmdW5jdGlvbiwgdXNlZCBhcyBkZWZhdWx0IGNhbGxiYWNrXFxuICBmdW5jdGlvbiBlbXB0eSgpIHt9XFxuXFxuICAkLmFqYXhKU09OUCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmVycmVkKXtcXG4gICAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpKSByZXR1cm4gJC5hamF4KG9wdGlvbnMpXFxuXFxuICAgIHZhciBfY2FsbGJhY2tOYW1lID0gb3B0aW9ucy5qc29ucENhbGxiYWNrLFxcbiAgICAgIGNhbGxiYWNrTmFtZSA9ICgkLmlzRnVuY3Rpb24oX2NhbGxiYWNrTmFtZSkgP1xcbiAgICAgICAgX2NhbGxiYWNrTmFtZSgpIDogX2NhbGxiYWNrTmFtZSkgfHwgKCdaZXB0bycgKyAoanNvbnBJRCsrKSksXFxuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXFxuICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IHdpbmRvd1tjYWxsYmFja05hbWVdLFxcbiAgICAgIHJlc3BvbnNlRGF0YSxcXG4gICAgICBhYm9ydCA9IGZ1bmN0aW9uKGVycm9yVHlwZSkge1xcbiAgICAgICAgJChzY3JpcHQpLnRyaWdnZXJIYW5kbGVyKCdlcnJvcicsIGVycm9yVHlwZSB8fCAnYWJvcnQnKVxcbiAgICAgIH0sXFxuICAgICAgeGhyID0geyBhYm9ydDogYWJvcnQgfSwgYWJvcnRUaW1lb3V0XFxuXFxuICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucHJvbWlzZSh4aHIpXFxuXFxuICAgICQoc2NyaXB0KS5vbignbG9hZCBlcnJvcicsIGZ1bmN0aW9uKGUsIGVycm9yVHlwZSl7XFxuICAgICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dClcXG4gICAgICAkKHNjcmlwdCkub2ZmKCkucmVtb3ZlKClcXG5cXG4gICAgICBpZiAoZS50eXBlID09ICdlcnJvcicgfHwgIXJlc3BvbnNlRGF0YSkge1xcbiAgICAgICAgYWpheEVycm9yKG51bGwsIGVycm9yVHlwZSB8fCAnZXJyb3InLCB4aHIsIG9wdGlvbnMsIGRlZmVycmVkKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhamF4U3VjY2VzcyhyZXNwb25zZURhdGFbMF0sIHhociwgb3B0aW9ucywgZGVmZXJyZWQpXFxuICAgICAgfVxcblxcbiAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gb3JpZ2luYWxDYWxsYmFja1xcbiAgICAgIGlmIChyZXNwb25zZURhdGEgJiYgJC5pc0Z1bmN0aW9uKG9yaWdpbmFsQ2FsbGJhY2spKVxcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjayhyZXNwb25zZURhdGFbMF0pXFxuXFxuICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IHJlc3BvbnNlRGF0YSA9IHVuZGVmaW5lZFxcbiAgICB9KVxcblxcbiAgICBpZiAoYWpheEJlZm9yZVNlbmQoeGhyLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcXG4gICAgICBhYm9ydCgnYWJvcnQnKVxcbiAgICAgIHJldHVybiB4aHJcXG4gICAgfVxcblxcbiAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKCl7XFxuICAgICAgcmVzcG9uc2VEYXRhID0gYXJndW1lbnRzXFxuICAgIH1cXG5cXG4gICAgc2NyaXB0LnNyYyA9IG9wdGlvbnMudXJsLnJlcGxhY2UoL1xcXFw/KC4rKT1cXFxcPy8sICc/JDE9JyArIGNhbGxiYWNrTmFtZSlcXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXFxuXFxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPiAwKSBhYm9ydFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XFxuICAgICAgYWJvcnQoJ3RpbWVvdXQnKVxcbiAgICB9LCBvcHRpb25zLnRpbWVvdXQpXFxuXFxuICAgIHJldHVybiB4aHJcXG4gIH1cXG5cXG4gICQuYWpheFNldHRpbmdzID0ge1xcbiAgICAvLyBEZWZhdWx0IHR5cGUgb2YgcmVxdWVzdFxcbiAgICB0eXBlOiAnR0VUJyxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBiZWZvcmUgcmVxdWVzdFxcbiAgICBiZWZvcmVTZW5kOiBlbXB0eSxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xcbiAgICBzdWNjZXNzOiBlbXB0eSxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCB0aGUgdGhlIHNlcnZlciBkcm9wcyBlcnJvclxcbiAgICBlcnJvcjogZW1wdHksXFxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgb24gcmVxdWVzdCBjb21wbGV0ZSAoYm90aDogZXJyb3IgYW5kIHN1Y2Nlc3MpXFxuICAgIGNvbXBsZXRlOiBlbXB0eSxcXG4gICAgLy8gVGhlIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3NcXG4gICAgY29udGV4dDogbnVsbCxcXG4gICAgLy8gV2hldGhlciB0byB0cmlnZ2VyIFxcXCJnbG9iYWxcXFwiIEFqYXggZXZlbnRzXFxuICAgIGdsb2JhbDogdHJ1ZSxcXG4gICAgLy8gVHJhbnNwb3J0XFxuICAgIHhocjogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KClcXG4gICAgfSxcXG4gICAgLy8gTUlNRSB0eXBlcyBtYXBwaW5nXFxuICAgIC8vIElJUyByZXR1cm5zIEphdmFzY3JpcHQgYXMgXFxcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFxcXCJcXG4gICAgYWNjZXB0czoge1xcbiAgICAgIHNjcmlwdDogJ3RleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24veC1qYXZhc2NyaXB0JyxcXG4gICAgICBqc29uOiAgIGpzb25UeXBlLFxcbiAgICAgIHhtbDogICAgJ2FwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwnLFxcbiAgICAgIGh0bWw6ICAgaHRtbFR5cGUsXFxuICAgICAgdGV4dDogICAndGV4dC9wbGFpbidcXG4gICAgfSxcXG4gICAgLy8gV2hldGhlciB0aGUgcmVxdWVzdCBpcyB0byBhbm90aGVyIGRvbWFpblxcbiAgICBjcm9zc0RvbWFpbjogZmFsc2UsXFxuICAgIC8vIERlZmF1bHQgdGltZW91dFxcbiAgICB0aW1lb3V0OiAwLFxcbiAgICAvLyBXaGV0aGVyIGRhdGEgc2hvdWxkIGJlIHNlcmlhbGl6ZWQgdG8gc3RyaW5nXFxuICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxcbiAgICAvLyBXaGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBiZSBhbGxvd2VkIHRvIGNhY2hlIEdFVCByZXNwb25zZXNcXG4gICAgY2FjaGU6IHRydWUsXFxuICAgIC8vVXNlZCB0byBoYW5kbGUgdGhlIHJhdyByZXNwb25zZSBkYXRhIG9mIFhNTEh0dHBSZXF1ZXN0LlxcbiAgICAvL1RoaXMgaXMgYSBwcmUtZmlsdGVyaW5nIGZ1bmN0aW9uIHRvIHNhbml0aXplIHRoZSByZXNwb25zZS5cXG4gICAgLy9UaGUgc2FuaXRpemVkIHJlc3BvbnNlIHNob3VsZCBiZSByZXR1cm5lZFxcbiAgICBkYXRhRmlsdGVyOiBlbXB0eVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWltZVRvRGF0YVR5cGUobWltZSkge1xcbiAgICBpZiAobWltZSkgbWltZSA9IG1pbWUuc3BsaXQoJzsnLCAyKVswXVxcbiAgICByZXR1cm4gbWltZSAmJiAoIG1pbWUgPT0gaHRtbFR5cGUgPyAnaHRtbCcgOlxcbiAgICAgIG1pbWUgPT0ganNvblR5cGUgPyAnanNvbicgOlxcbiAgICAgIHNjcmlwdFR5cGVSRS50ZXN0KG1pbWUpID8gJ3NjcmlwdCcgOlxcbiAgICAgIHhtbFR5cGVSRS50ZXN0KG1pbWUpICYmICd4bWwnICkgfHwgJ3RleHQnXFxuICB9XFxuXFxuICBmdW5jdGlvbiBhcHBlbmRRdWVyeSh1cmwsIHF1ZXJ5KSB7XFxuICAgIGlmIChxdWVyeSA9PSAnJykgcmV0dXJuIHVybFxcbiAgICByZXR1cm4gKHVybCArICcmJyArIHF1ZXJ5KS5yZXBsYWNlKC9bJj9dezEsMn0vLCAnPycpXFxuICB9XFxuXFxuICAvLyBzZXJpYWxpemUgcGF5bG9hZCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBVUkwgZm9yIEdFVCByZXF1ZXN0c1xcbiAgZnVuY3Rpb24gc2VyaWFsaXplRGF0YShvcHRpb25zKSB7XFxuICAgIGlmIChvcHRpb25zLnByb2Nlc3NEYXRhICYmIG9wdGlvbnMuZGF0YSAmJiAkLnR5cGUob3B0aW9ucy5kYXRhKSAhPSBcXFwic3RyaW5nXFxcIilcXG4gICAgICBvcHRpb25zLmRhdGEgPSAkLnBhcmFtKG9wdGlvbnMuZGF0YSwgb3B0aW9ucy50cmFkaXRpb25hbClcXG4gICAgaWYgKG9wdGlvbnMuZGF0YSAmJiAoIW9wdGlvbnMudHlwZSB8fCBvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSA9PSAnR0VUJyB8fCAnanNvbnAnID09IG9wdGlvbnMuZGF0YVR5cGUpKVxcbiAgICAgIG9wdGlvbnMudXJsID0gYXBwZW5kUXVlcnkob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSksIG9wdGlvbnMuZGF0YSA9IHVuZGVmaW5lZFxcbiAgfVxcblxcbiAgJC5hamF4ID0gZnVuY3Rpb24ob3B0aW9ucyl7XFxuICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9KSxcXG4gICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCAmJiAkLkRlZmVycmVkKCksXFxuICAgICAgICB1cmxBbmNob3IsIGhhc2hJbmRleFxcbiAgICBmb3IgKGtleSBpbiAkLmFqYXhTZXR0aW5ncykgaWYgKHNldHRpbmdzW2tleV0gPT09IHVuZGVmaW5lZCkgc2V0dGluZ3Nba2V5XSA9ICQuYWpheFNldHRpbmdzW2tleV1cXG5cXG4gICAgYWpheFN0YXJ0KHNldHRpbmdzKVxcblxcbiAgICBpZiAoIXNldHRpbmdzLmNyb3NzRG9tYWluKSB7XFxuICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXFxuICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzZXR0aW5ncy51cmxcXG4gICAgICAvLyBjbGVhbnMgdXAgVVJMIGZvciAuaHJlZiAoSUUgb25seSksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFkcm9iYnkvemVwdG8vcHVsbC8xMDQ5XFxuICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZlxcbiAgICAgIHNldHRpbmdzLmNyb3NzRG9tYWluID0gKG9yaWdpbkFuY2hvci5wcm90b2NvbCArICcvLycgKyBvcmlnaW5BbmNob3IuaG9zdCkgIT09ICh1cmxBbmNob3IucHJvdG9jb2wgKyAnLy8nICsgdXJsQW5jaG9yLmhvc3QpXFxuICAgIH1cXG5cXG4gICAgaWYgKCFzZXR0aW5ncy51cmwpIHNldHRpbmdzLnVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpXFxuICAgIGlmICgoaGFzaEluZGV4ID0gc2V0dGluZ3MudXJsLmluZGV4T2YoJyMnKSkgPiAtMSkgc2V0dGluZ3MudXJsID0gc2V0dGluZ3MudXJsLnNsaWNlKDAsIGhhc2hJbmRleClcXG4gICAgc2VyaWFsaXplRGF0YShzZXR0aW5ncylcXG5cXG4gICAgdmFyIGRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUsIGhhc1BsYWNlaG9sZGVyID0gL1xcXFw/Lis9XFxcXD8vLnRlc3Qoc2V0dGluZ3MudXJsKVxcbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIGRhdGFUeXBlID0gJ2pzb25wJ1xcblxcbiAgICBpZiAoc2V0dGluZ3MuY2FjaGUgPT09IGZhbHNlIHx8IChcXG4gICAgICAgICAoIW9wdGlvbnMgfHwgb3B0aW9ucy5jYWNoZSAhPT0gdHJ1ZSkgJiZcXG4gICAgICAgICAoJ3NjcmlwdCcgPT0gZGF0YVR5cGUgfHwgJ2pzb25wJyA9PSBkYXRhVHlwZSlcXG4gICAgICAgICkpXFxuICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLCAnXz0nICsgRGF0ZS5ub3coKSlcXG5cXG4gICAgaWYgKCdqc29ucCcgPT0gZGF0YVR5cGUpIHtcXG4gICAgICBpZiAoIWhhc1BsYWNlaG9sZGVyKVxcbiAgICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLFxcbiAgICAgICAgICBzZXR0aW5ncy5qc29ucCA/IChzZXR0aW5ncy5qc29ucCArICc9PycpIDogc2V0dGluZ3MuanNvbnAgPT09IGZhbHNlID8gJycgOiAnY2FsbGJhY2s9PycpXFxuICAgICAgcmV0dXJuICQuYWpheEpTT05QKHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgfVxcblxcbiAgICB2YXIgbWltZSA9IHNldHRpbmdzLmFjY2VwdHNbZGF0YVR5cGVdLFxcbiAgICAgICAgaGVhZGVycyA9IHsgfSxcXG4gICAgICAgIHNldEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7IGhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IFtuYW1lLCB2YWx1ZV0gfSxcXG4gICAgICAgIHByb3RvY29sID0gL14oW1xcXFx3LV0rOilcXFxcL1xcXFwvLy50ZXN0KHNldHRpbmdzLnVybCkgPyBSZWdFeHAuJDEgOiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wsXFxuICAgICAgICB4aHIgPSBzZXR0aW5ncy54aHIoKSxcXG4gICAgICAgIG5hdGl2ZVNldEhlYWRlciA9IHhoci5zZXRSZXF1ZXN0SGVhZGVyLFxcbiAgICAgICAgYWJvcnRUaW1lb3V0XFxuXFxuICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucHJvbWlzZSh4aHIpXFxuXFxuICAgIGlmICghc2V0dGluZ3MuY3Jvc3NEb21haW4pIHNldEhlYWRlcignWC1SZXF1ZXN0ZWQtV2l0aCcsICdYTUxIdHRwUmVxdWVzdCcpXFxuICAgIHNldEhlYWRlcignQWNjZXB0JywgbWltZSB8fCAnKi8qJylcXG4gICAgaWYgKG1pbWUgPSBzZXR0aW5ncy5taW1lVHlwZSB8fCBtaW1lKSB7XFxuICAgICAgaWYgKG1pbWUuaW5kZXhPZignLCcpID4gLTEpIG1pbWUgPSBtaW1lLnNwbGl0KCcsJywgMilbMF1cXG4gICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZShtaW1lKVxcbiAgICB9XFxuICAgIGlmIChzZXR0aW5ncy5jb250ZW50VHlwZSB8fCAoc2V0dGluZ3MuY29udGVudFR5cGUgIT09IGZhbHNlICYmIHNldHRpbmdzLmRhdGEgJiYgc2V0dGluZ3MudHlwZS50b1VwcGVyQ2FzZSgpICE9ICdHRVQnKSlcXG4gICAgICBzZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIHNldHRpbmdzLmNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKVxcblxcbiAgICBpZiAoc2V0dGluZ3MuaGVhZGVycykgZm9yIChuYW1lIGluIHNldHRpbmdzLmhlYWRlcnMpIHNldEhlYWRlcihuYW1lLCBzZXR0aW5ncy5oZWFkZXJzW25hbWVdKVxcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlciA9IHNldEhlYWRlclxcblxcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5XFxuICAgICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KVxcbiAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3IgPSBmYWxzZVxcbiAgICAgICAgaWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09IDMwNCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHByb3RvY29sID09ICdmaWxlOicpKSB7XFxuICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUgfHwgbWltZVRvRGF0YVR5cGUoc2V0dGluZ3MubWltZVR5cGUgfHwgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSlcXG5cXG4gICAgICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT0gJ2FycmF5YnVmZmVyJyB8fCB4aHIucmVzcG9uc2VUeXBlID09ICdibG9iJylcXG4gICAgICAgICAgICByZXN1bHQgPSB4aHIucmVzcG9uc2VcXG4gICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dFxcblxcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9nbG9iYWwtZXZhbC13aGF0LWFyZS10aGUtb3B0aW9ucy9cXG4gICAgICAgICAgICAgIC8vIHNhbml0aXplIHJlc3BvbnNlIGFjY29yZGluZ2x5IGlmIGRhdGEgZmlsdGVyIGNhbGxiYWNrIHByb3ZpZGVkXFxuICAgICAgICAgICAgICByZXN1bHQgPSBhamF4RGF0YUZpbHRlcihyZXN1bHQsIGRhdGFUeXBlLCBzZXR0aW5ncylcXG4gICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSAnc2NyaXB0JykgICAgKDEsZXZhbCkocmVzdWx0KVxcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT0gJ3htbCcpICByZXN1bHQgPSB4aHIucmVzcG9uc2VYTUxcXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09ICdqc29uJykgcmVzdWx0ID0gYmxhbmtSRS50ZXN0KHJlc3VsdCkgPyBudWxsIDogJC5wYXJzZUpTT04ocmVzdWx0KVxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgZXJyb3IgPSBlIH1cXG5cXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBhamF4RXJyb3IoZXJyb3IsICdwYXJzZXJlcnJvcicsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFqYXhTdWNjZXNzKHJlc3VsdCwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBhamF4RXJyb3IoeGhyLnN0YXR1c1RleHQgfHwgbnVsbCwgeGhyLnN0YXR1cyA/ICdlcnJvcicgOiAnYWJvcnQnLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpID09PSBmYWxzZSkge1xcbiAgICAgIHhoci5hYm9ydCgpXFxuICAgICAgYWpheEVycm9yKG51bGwsICdhYm9ydCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgIHJldHVybiB4aHJcXG4gICAgfVxcblxcbiAgICB2YXIgYXN5bmMgPSAnYXN5bmMnIGluIHNldHRpbmdzID8gc2V0dGluZ3MuYXN5bmMgOiB0cnVlXFxuICAgIHhoci5vcGVuKHNldHRpbmdzLnR5cGUsIHNldHRpbmdzLnVybCwgYXN5bmMsIHNldHRpbmdzLnVzZXJuYW1lLCBzZXR0aW5ncy5wYXNzd29yZClcXG5cXG4gICAgaWYgKHNldHRpbmdzLnhockZpZWxkcykgZm9yIChuYW1lIGluIHNldHRpbmdzLnhockZpZWxkcykgeGhyW25hbWVdID0gc2V0dGluZ3MueGhyRmllbGRzW25hbWVdXFxuXFxuICAgIGZvciAobmFtZSBpbiBoZWFkZXJzKSBuYXRpdmVTZXRIZWFkZXIuYXBwbHkoeGhyLCBoZWFkZXJzW25hbWVdKVxcblxcbiAgICBpZiAoc2V0dGluZ3MudGltZW91dCA+IDApIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eVxcbiAgICAgICAgeGhyLmFib3J0KClcXG4gICAgICAgIGFqYXhFcnJvcihudWxsLCAndGltZW91dCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgIH0sIHNldHRpbmdzLnRpbWVvdXQpXFxuXFxuICAgIC8vIGF2b2lkIHNlbmRpbmcgZW1wdHkgc3RyaW5nICgjMzE5KVxcbiAgICB4aHIuc2VuZChzZXR0aW5ncy5kYXRhID8gc2V0dGluZ3MuZGF0YSA6IG51bGwpXFxuICAgIHJldHVybiB4aHJcXG4gIH1cXG5cXG4gIC8vIGhhbmRsZSBvcHRpb25hbCBkYXRhL3N1Y2Nlc3MgYXJndW1lbnRzXFxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyh1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlKSB7XFxuICAgIGlmICgkLmlzRnVuY3Rpb24oZGF0YSkpIGRhdGFUeXBlID0gc3VjY2Vzcywgc3VjY2VzcyA9IGRhdGEsIGRhdGEgPSB1bmRlZmluZWRcXG4gICAgaWYgKCEkLmlzRnVuY3Rpb24oc3VjY2VzcykpIGRhdGFUeXBlID0gc3VjY2Vzcywgc3VjY2VzcyA9IHVuZGVmaW5lZFxcbiAgICByZXR1cm4ge1xcbiAgICAgIHVybDogdXJsXFxuICAgICwgZGF0YTogZGF0YVxcbiAgICAsIHN1Y2Nlc3M6IHN1Y2Nlc3NcXG4gICAgLCBkYXRhVHlwZTogZGF0YVR5cGVcXG4gICAgfVxcbiAgfVxcblxcbiAgJC5nZXQgPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlICovKXtcXG4gICAgcmV0dXJuICQuYWpheChwYXJzZUFyZ3VtZW50cy5hcHBseShudWxsLCBhcmd1bWVudHMpKVxcbiAgfVxcblxcbiAgJC5wb3N0ID0gZnVuY3Rpb24oLyogdXJsLCBkYXRhLCBzdWNjZXNzLCBkYXRhVHlwZSAqLyl7XFxuICAgIHZhciBvcHRpb25zID0gcGFyc2VBcmd1bWVudHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxcbiAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCdcXG4gICAgcmV0dXJuICQuYWpheChvcHRpb25zKVxcbiAgfVxcblxcbiAgJC5nZXRKU09OID0gZnVuY3Rpb24oLyogdXJsLCBkYXRhLCBzdWNjZXNzICovKXtcXG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZUFyZ3VtZW50cy5hcHBseShudWxsLCBhcmd1bWVudHMpXFxuICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAnanNvbidcXG4gICAgcmV0dXJuICQuYWpheChvcHRpb25zKVxcbiAgfVxcblxcbiAgJC5mbi5sb2FkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBzdWNjZXNzKXtcXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNcXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBwYXJ0cyA9IHVybC5zcGxpdCgvXFxcXHMvKSwgc2VsZWN0b3IsXFxuICAgICAgICBvcHRpb25zID0gcGFyc2VBcmd1bWVudHModXJsLCBkYXRhLCBzdWNjZXNzKSxcXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucy5zdWNjZXNzXFxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSBvcHRpb25zLnVybCA9IHBhcnRzWzBdLCBzZWxlY3RvciA9IHBhcnRzWzFdXFxuICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3BvbnNlKXtcXG4gICAgICBzZWxmLmh0bWwoc2VsZWN0b3IgP1xcbiAgICAgICAgJCgnPGRpdj4nKS5odG1sKHJlc3BvbnNlLnJlcGxhY2UocnNjcmlwdCwgXFxcIlxcXCIpKS5maW5kKHNlbGVjdG9yKVxcbiAgICAgICAgOiByZXNwb25zZSlcXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHMpXFxuICAgIH1cXG4gICAgJC5hamF4KG9wdGlvbnMpXFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxuICB2YXIgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50XFxuXFxuICBmdW5jdGlvbiBzZXJpYWxpemUocGFyYW1zLCBvYmosIHRyYWRpdGlvbmFsLCBzY29wZSl7XFxuICAgIHZhciB0eXBlLCBhcnJheSA9ICQuaXNBcnJheShvYmopLCBoYXNoID0gJC5pc1BsYWluT2JqZWN0KG9iailcXG4gICAgJC5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIHR5cGUgPSAkLnR5cGUodmFsdWUpXFxuICAgICAgaWYgKHNjb3BlKSBrZXkgPSB0cmFkaXRpb25hbCA/IHNjb3BlIDpcXG4gICAgICAgIHNjb3BlICsgJ1snICsgKGhhc2ggfHwgdHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdhcnJheScgPyBrZXkgOiAnJykgKyAnXSdcXG4gICAgICAvLyBoYW5kbGUgZGF0YSBpbiBzZXJpYWxpemVBcnJheSgpIGZvcm1hdFxcbiAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpXFxuICAgICAgLy8gcmVjdXJzZSBpbnRvIG5lc3RlZCBvYmplY3RzXFxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcXFwiYXJyYXlcXFwiIHx8ICghdHJhZGl0aW9uYWwgJiYgdHlwZSA9PSBcXFwib2JqZWN0XFxcIikpXFxuICAgICAgICBzZXJpYWxpemUocGFyYW1zLCB2YWx1ZSwgdHJhZGl0aW9uYWwsIGtleSlcXG4gICAgICBlbHNlIHBhcmFtcy5hZGQoa2V5LCB2YWx1ZSlcXG4gICAgfSlcXG4gIH1cXG5cXG4gICQucGFyYW0gPSBmdW5jdGlvbihvYmosIHRyYWRpdGlvbmFsKXtcXG4gICAgdmFyIHBhcmFtcyA9IFtdXFxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbih2YWx1ZSkpIHZhbHVlID0gdmFsdWUoKVxcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9IFxcXCJcXFwiXFxuICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSlcXG4gICAgfVxcbiAgICBzZXJpYWxpemUocGFyYW1zLCBvYmosIHRyYWRpdGlvbmFsKVxcbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKVxcbiAgfVxcbn0pKFplcHRvKVxcblxcbjsoZnVuY3Rpb24oJCl7XFxuICAkLmZuLnNlcmlhbGl6ZUFycmF5ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBuYW1lLCB0eXBlLCByZXN1bHQgPSBbXSxcXG4gICAgICBhZGQgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgaWYgKHZhbHVlLmZvckVhY2gpIHJldHVybiB2YWx1ZS5mb3JFYWNoKGFkZClcXG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pXFxuICAgICAgfVxcbiAgICBpZiAodGhpc1swXSkgJC5lYWNoKHRoaXNbMF0uZWxlbWVudHMsIGZ1bmN0aW9uKF8sIGZpZWxkKXtcXG4gICAgICB0eXBlID0gZmllbGQudHlwZSwgbmFtZSA9IGZpZWxkLm5hbWVcXG4gICAgICBpZiAobmFtZSAmJiBmaWVsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdmaWVsZHNldCcgJiZcXG4gICAgICAgICFmaWVsZC5kaXNhYmxlZCAmJiB0eXBlICE9ICdzdWJtaXQnICYmIHR5cGUgIT0gJ3Jlc2V0JyAmJiB0eXBlICE9ICdidXR0b24nICYmIHR5cGUgIT0gJ2ZpbGUnICYmXFxuICAgICAgICAoKHR5cGUgIT0gJ3JhZGlvJyAmJiB0eXBlICE9ICdjaGVja2JveCcpIHx8IGZpZWxkLmNoZWNrZWQpKVxcbiAgICAgICAgICBhZGQoJChmaWVsZCkudmFsKCkpXFxuICAgIH0pXFxuICAgIHJldHVybiByZXN1bHRcXG4gIH1cXG5cXG4gICQuZm4uc2VyaWFsaXplID0gZnVuY3Rpb24oKXtcXG4gICAgdmFyIHJlc3VsdCA9IFtdXFxuICAgIHRoaXMuc2VyaWFsaXplQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uKGVsbSl7XFxuICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGVsbS5uYW1lKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChlbG0udmFsdWUpKVxcbiAgICB9KVxcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxcbiAgfVxcblxcbiAgJC5mbi5zdWJtaXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xcbiAgICBpZiAoMCBpbiBhcmd1bWVudHMpIHRoaXMuYmluZCgnc3VibWl0JywgY2FsbGJhY2spXFxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoKSB7XFxuICAgICAgdmFyIGV2ZW50ID0gJC5FdmVudCgnc3VibWl0JylcXG4gICAgICB0aGlzLmVxKDApLnRyaWdnZXIoZXZlbnQpXFxuICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgdGhpcy5nZXQoMCkuc3VibWl0KClcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbn0pKFplcHRvKVxcblxcbjsoZnVuY3Rpb24oKXtcXG4gIC8vIGdldENvbXB1dGVkU3R5bGUgc2hvdWxkbid0IGZyZWFrIG91dCB3aGVuIGNhbGxlZFxcbiAgLy8gd2l0aG91dCBhIHZhbGlkIGVsZW1lbnQgYXMgYXJndW1lbnRcXG4gIHRyeSB7XFxuICAgIGdldENvbXB1dGVkU3R5bGUodW5kZWZpbmVkKVxcbiAgfSBjYXRjaChlKSB7XFxuICAgIHZhciBuYXRpdmVHZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZVxcbiAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpe1xcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXR1cm4gbmF0aXZlR2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBwc2V1ZG9FbGVtZW50KVxcbiAgICAgIH0gY2F0Y2goZSkge1xcbiAgICAgICAgcmV0dXJuIG51bGxcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59KSgpXFxuICByZXR1cm4gWmVwdG9cXG59KSlcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")}]]);